Date: 2022 September 26th
Author: Dean Zhou
topic: sort algorithm

1. 简单排序
    1.1 comparable接口排序
    java comparable 接口 ，自定义规则，对comparable实现类对象进行排序

    1.2 冒泡排序（bubble sort）

        排序前：（4，5，6，3，2，1）
        排序后：（1，2，3，4，5，6）

        a. 排序原理
           1. 比较相邻元素，如果前一个元素比后一个元素大，就交换这两个元素位置
           2. 对每一对相邻元素做同样的工作，从开始第一对元素，到结尾最后一对元素，最终最后的元素就是最大值

             冒泡次数                            冒泡后的结果
             初始状态                            4，5，6，3，2，1
             第 1 次冒泡                         4，5，3，2，1，（6）
             第 2 次冒泡                         4，3，2，1，（5，6）
             第 3 次冒泡                         3，2，1，（4，5，6）
             第 4 次冒泡                         2，1，（3，4，5，6）
             第 5 次冒泡                         1，（2，3，4，5，6）
             第 6 次冒泡                         1，2，3，4，5，6  结束


        b. 时间复杂度分析 （最坏情况）
            元素比较次数 ： n-1 + n-2 + n-3+..... + 2+1 = n^2/2 - n/2
            元素交换次数 ： n-1 + n-2 + n-3+..... + 2+1 = n^2/2 - n/2

            总的次数为：n^2 - n
            即时间复杂度为 O(n^2)


    1.3 选择排序
        需求：
            排序前：（4，6，8，7，9，2，10，1）
            排序后：（1，2，4，5，7，8，9，10）

        a.排序原理
           1.每一次遍历的过程中，都假定第一个索引的元素是最小值，和其他索引处的值依次进行比较，如果当前索引处的值大于其他索引处的值，则
             假定其他索引处的值为最小值，依次类推，最后找到最小值所在索引
           2.交换第一个索引处的值和最小索引处的值

                        4 ，6 ，8 ，7 ，9 ，2 ，10 ，1         原始数据

                      （1），6 ，8 ，7 ，9 ，2 ，10 ，（4）     第一趟排序 min = 1

                        1,（2），8 ，7 ，9 ，（6） ，10 ，4     第二趟排序 min = 2

                        1 ，2 ，（4） ，7 ，9 ，6，10 ，（8）   第三趟排序 min = 4

                        1 ，2 ，4 ，（6） ，9 ，（7），10 ，8   第四趟排序 min = 6

                        1 ，2 ，4 ，6 ，（7），（9），10 ，8    第五趟排序 min = 7

                        1 ，2 ，4 ，6 ，7，（8），10 ，（9）    第六趟排序 min = 8

                        1 ，2 ，4 ，6 ，7 ，8 ，（9），（10）   第六趟排序 min = 9

        b. 时间复杂度分析
            数据比较次数 ：
             （n-1）+ （n-2） +  ..... + 3 + 2 + 1 = n^2/n -n/2
             数据交换次数：
             n -1

             时间复杂度 n^2/n -n/2 + n -1 = n^2/n + n/2-1
             大O记法：  O(n^2)

    1.4 插入排序（insertion sort）
        简单直观稳定的排序算法

        需求：
         排序前：（4，3，2，10，12，1，5，6）
         排序后：（1，2，3，4，5，6，10，12）

        a. 排序原理：
         1. 把所有元素分为两组已经排序的和未排序的
         2. 找到未排序的第一个元素，向已排序的组中进行插入
         3.倒叙遍历已经排序的元素，依次和待插入的元素进行比较，直到找到一个元素小于等于待插入元素，就把待插入元素放到这个位置，其他元素向后移动一位


                        4，3，2，10，12，1，5，6                  原始数据
                        4，（3），2，10，12，1，5，6               第一趟排序（待插入数字为 3）
                        3，4，（2），10，12，1，5，6               第二趟排序（待插入数字为 2）
                        2，3，4，（10），12，1，5，6               第三趟排序（待插入数字为 10）
                        2，3，4，10，（12），1，5，6               第四趟排序（待插入数字为 12）
                        2，3，4，10，12，（1），5，6               第五趟排序（待插入数字为 1）
                        1，2，3，4，10，12，（5），6               第六趟排序（待插入数字为 5）
                        1，2，3，4，5，10，12，（6 ）              第七趟排序（待插入数字为 6）
                        1，2，3，4，5，6，10，12，                 最终结果

        b. 时间复杂度分析
                    数据比较次数 ：
                     （n-1）+ （n-2） +  ..... + 3 + 2 + 1 = n^2/n -n/2
                     数据交换次数：
                     n-1）+ （n-2） +  ..... + 3 + 2 + 1 = n^2/n -n/2

                     时间复杂度 n^2 -n
                     大O记法：  O(n^2)


2.高级排序
    2.1 希尔排序
            "缩小量产排序" ，插入排序算法更高效版本

            需求：
             排序前：（9，1，2，5，7，4，8，6，3，5）
             排序后：（1，2，3，4，5，5，6，7，8，9）

         a.排序原理
            1.选定一个增长量h，按照增长量h作为数据分组的依据，对数据进行分组
            2.对分好组对每一组数据完成插入排序
            3.减小增长量 ， 最小减为1，重复第二部操作

                初始    9 ，1 ，2 ，5 ，7 ，4 ，8 ，6 ，3 ，5

               h=5     0   1  2    3  4   5  6   7   8   9
            第一趟排序   9 ，1 ，2 ，5 ，7 ，4 ，8 ，6 ，3 ，5

                      （4） ，1 ，2 ，【3】 ，「5」，（9） ，8 ，6 ，【5】 ，「7」

               h=2
            第二趟排序   4 ，1 ，2 ，3 ，5 ，9 ，8 ，6 ，5 ，7
                                                           该地方9换了两次
                      （2） ，1 ，（4） ，3 ，5 ，【6】 ，「5」 ，<【7】> ，「8」 ，<9>

              h=1
            第三趟排序   2 ，1 ，4 ，3 ，5 ，6 ，5 ，7 ，8 ，9

                      （1）,（2） , <3> ，<4> , 5 , [5] , [6] , 7 , 8 , 9


            增长量的确定：
            固定规则
               int h=1
               while( h < 数组长度/2){
                  h= 2h+1
               }
              // 循环结束后确定h的最大值
              h的减小规则
                h= h/2

        b. 希尔排序时间复杂度分析
            Shell排序比插入排序快很多


    2.2 归并排序
            1.递归
                a.递归：

                    1. 定义：在定义方法时，在方法内部调用方法本身，称之为递归

                        public void show(){
                            sout("aaaa");
                            show();
                          }

                b. 作用: 把一个大型的问题层层转换为一个相似的小问题，通过少量的代码就可以描述出代码的多次运算，解决问题

                c. 注意事项：必须要有边界条件，能让递归结束，如果递归层级太深，很容易造成占内存溢出

            2.归并排序
                a.定义：
                    归并排序是建立在归并的基础之上的一种有效的算法，该算法是采用分治法的一个典型的应用。
                    将两个有序表合并成一个有序表，称为二路归并

                需求：
                    （ 8 ，4 ，5 ，7 ，1 ，3 ，6 ，2 ）
                    （ 1 ，2 ，3 ，4 ，5 ，6 ，7 ，8 ）

                b.排序原理
                    1 尽可能的一组数据拆分两个元素相等的子组，并对每一个子组进行拆分，直到拆分后的每一个子组元素都是1
                    2 将两个相邻的子组合并为一个有序的大组
                    3 不断重复步骤2，直到只有一个大组


                   原始数据                     8 ，4 ，5 ，7 ，1 ，3 ，6 ，2
                                                        /       \
                   第一次拆分              （ 8 ，4 ，5 ，7）      （ 1 ，3 ，6 ，2）
                                              /       \             /       \
                   第二次拆分             （8，4）      （5，7）    （1，3）     （6，2）
                                         /    \       /    \     /    \       /    \
                    ----------------------------------------------------------------
                   第三次拆分            8       4     5      7   1     3      6     2
                （此时每组只有1个元素）
                    ----------------------------------------------------------------
                                         \    /        \    /    \    /       \    /
                   第一次重组              (4,8)         (5,7)     (1,3)        (2,6)
                                            \              /         \           /
                   第二次重组                 (4 , 5 , 7 , 8)         (1 , 2 , 3 , 6)
                                                  \                       /
                   第三次重组                     (1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 )


                c.归并的原理：
                    前提：
                    int lo = 0;
                    int hi = 5;
                    int mid = lo + (hi-lo)/2
                    sort(a,lo,mid)
                    sort(a,mid,hi)
                    调用merge(a,lo,mid,hi)
    2.3 快速排序
    2.4 排序稳定性