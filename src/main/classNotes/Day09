Date: 2022 November 9th
Author: Dean Zhou
topic: map

一. 图的入门
    a)图的实际应用
    b)图的定义及分类
        1.定义：图是有一组顶点和一组能够将两个顶点相邻的边组成

            (0)---------(2)            (7)---------(8)
             | \         |
             |   (1)     |
            (3)---------(5)
         特殊的图：
           自环：即一条连接一个顶点和其自身的边
           平行边：连同一对顶点的两条边

                      /---\  / \             --> 平行边
                    (0)————(1)  |            --> 自环
                       \__/  \ /

        2.图的分类
          无向图：边紧紧连接两个顶点，没有其他含义
          有向图：边不仅连接两个顶点，并且有具体方向
    c)无向图
        1.图的相关术语

            相邻顶点：
                当两个顶点通过一条边相连时，我们称这两个顶点是相邻的，并且这条边依附于这两个顶点
            度：
                某个顶点的度就是依附于该顶点边的个数
            子图：
                是一幅图所有边的子集包含这些边依附的顶点组成的图
            路径：
                是由边顺序连接的一系列的顶点组成
            环：
                是一条至少含有一条边且终点起点相同的路径
            连通图：
                如果任意一个图中任意一个顶点都存在一条路径到达另外一个顶点，那么就称这幅图为连通图
            连通子图：
                一个非连通图由若干个部分组成，每一个连通的部分可以称为连通子图

        2.图的存储结构
            表示一幅图，表示两个部分即可：
            1. 图中所有的顶点
            2. 所有连接顶点的边
            常见图形结构：邻接矩阵 ，邻接表

                邻接矩阵
                1. 使用一个V*V的二维数组int[V][V]adj,把索引的值看做是顶点
                2. 如果顶点V和顶点W相连，我们只需将adj[V][W]和adj[W][V]的值设置为1，否则设置为0

                空间复杂度V*2,如果遇到大量的数据，内存空间可能不够用

                邻接表
                1.使用一个大小为V数组Queue[V]adj,把索引看做是顶点
                2.每个索引处adj[V]存储了一个队列，该队列中存储的是所有与该顶点相邻的其他顶点

                adj[]数组的索引表示顶点，索引处还存储着queue对象


                                                                      [6]->[2]->[1]->[5] \
                (0)                                         adj[]   / [0]           queue
                 |\   \    \                                  0[] / / [0]      /    对象
                 |  \    \    \                               1[] / / [5]->[4]
                 |   (1)  (2)  (6)                            2[] / / [5]->[6]->[3]
                 |              /                             3[] / /
                 |     (3)--(4)                               4[] /
                 |   /     /                                  5[]  ....
                (5)    /                                      6[]
                                                              7[]  -- [8]  表示同一条边连接7和8
                                                              8[]  -- [7]
                (7)--(8)            (9) --(10)                9[]   ....
                                     |  \                    10[]
                                    (11)--(12)               11[]
                                                             12[]  -- [11]->[9]

                邻接表存储空间不是线性级别的，可以采用邻接表这种形式存储数据


    d)图的实现
        1. 图的API设计

        类名                                          Graph

        构造方法                                       Graph(int V):创建一个V顶点但是不包含边的图

        成员方法                                       int V():获取图中顶点的数量
                                                      int E():获取图中边的数量
                                                      void addEdge(int V,int W):向图中添加一条边V-W
                                                      Queue<integer> adj(int v):获取和顶点V相邻的所有顶点

        成员变量                                       final int V:记录顶点数量
                                                      int E：记录边的数量
                                                      Queue<integer>[] adj:邻接表
        2. 代码实现
    e)图的搜索
        1. 深度优先搜索
            定义：指在搜索时，如果遇到一个结点既有子结点又有兄弟结点，那么先找子结点，然后找兄弟结点

                                                                      [6]->[2]->[1]->[5] \
                (0)                                         adj[]   / [0]           queue
                 |\   \    \                                  0[] / / [0]      /    对象
                 |  \    \    \                               1[] / / [5]->[4]
                 |   (1)  (2)  (6)                            2[] / / [5]->[6]->[3]
                 |              /                             3[] / /
                 |     (3)--(4)                               4[] /
                 |   /     /                                  5[]  ....
                (5)    /                                      6[]

              深度优先： 查找顶点0相通的所有顶点 0 ->6 ->4->5 ->3  子结点优先


            API设计

             类名                                          DepthFirstSearch

             构造方法                                       DepthFirstSearch(Graph G,int s):构建深度优先搜索对象，使用深度优先搜索找出G图中V顶点的所有想通顶点

             成员方法                                       void dfs(Graph G,int s):深度优先搜索找出G图中V顶点的所有想通顶点
                                                           boolean marked(int w):判断w顶点与s顶点是否想通
                                                           int count():获取与顶点s相通的所有顶点总数


             成员变量                                       boolean[] marked:索引代表顶点，值表示当前顶点是否已经被搜索
                                                           int count：记录多少个顶点被搜索

        2. 广度优先搜索（类似于层序遍历）
              定义：指在搜索时，如果遇到一个结点既有子结点又有兄弟结点，那么先找兄弟结点，然后找子结点

                                                          [6]->[2]->[1]->[5] \
                (0)                                         adj[]   / [0]           queue
                 |\   \    \                                  0[] / / [0]      /    对象
                 |  \    \    \                               1[] / / [5]->[4]
                 |   (1)  (2)  (6)                            2[] / / [5]->[6]->[3]
                 |              /                             3[] / /
                 |     (3)--(4)                               4[] /
                 |   /     /                                  5[]  ....
                (5)    /                                      6[]

              广度优先： 查找顶点0相通的所有顶点 0 ->6 ->2 ->1 ->5 兄弟结点优先

            API设计

             类名                                          BreadthFirstSearch

             构造方法                                       BreadthFirstSearch(Graph G,int s):构建广度优先搜索对象，使用广度优先搜索找出G图中V顶点的所有想通顶点

             成员方法                                       void bfs(Graph G,int s):广度优先搜索找出G图中V顶点的所有想通顶点
                                                           boolean marked(int w):判断w顶点与s顶点是否想通
                                                           int count():获取与顶点s相通的所有顶点总数


             成员变量                                       boolean[] marked:索引代表顶点，值表示当前顶点是否已经被搜索
                                                           int count：记录多少个顶点被搜索
                                                           Queue<Integer> waitSearch:用来存储待搜索邻接表的点

    f)案例：畅通工程续1
           某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直通的城镇。省政府畅通工程的目标是使全省任何
           两个城镇实现畅通（不一定要直接相连，只要相互之间道路可达),目前情况9号城市和10号城市道路是否相通？
           9号城市和8号城市道路是否相通？
           测试数据中有一个traffic_project.txt文件，它就是城镇道路统计表

                                                    20       --- 城市个数
                                                    7        --- 已修建好的道路数目
                                                    0 1      -
                                                    6 9      |
                                                    3 8      |
                                                    5 11     | -->  已经修好的城市道路每行数据代表2个城市，
                                                    2 12     |      表示这两个城市已经相通
                                                    6 10     |
                                                    4 8      -

           解题思路：1. 创建一个Graph表示城市
                    2.分别调用addEdge(0,1)。。。。。。。。表示已经修建好的道路和对应道路相连接
           代码实现：day09 traffic_project_test2

    g)路径查找

                       6        --- 个顶点
                       8        --- 条边                             (0)------------(2)
                       0 2      -                                     |\          / /|
                       0 1      |                                     |  \    /    / |
                       2 1      |                                     |   (1)     /  |
                       2 3      | -->                                 |         /    |
                       2 4      |                                     |       (3)    |
                       3 5      |                                     |   /       \  |
                       3 4      |                                     | /           \|
                       0 5      -                                    (5)            (4)


                         在上图中找到从0，4的路径为0-2-3-4

             API设计

             类名                                          DepthFirstPaths

             构造方法                                       DepthFirstPaths(Graph G,int s):构建深度优先搜索对象，使用深度优先搜索找出G图中V顶点的所有想通顶点

             成员方法                                       void dfs(Graph G,int s):深度优先搜索找出G图中V顶点的所有想通顶点
                                                           boolean hasPathTo(int v):判断v顶点与s顶点是否存在路径
                                                           Stack<Integer> pathTo(int v):找出从顶点s到起点v的路径（该路径经过顶点）


             成员变量                                       boolean[] marked:索引代表顶点，值表示当前顶点是否已经被搜索
                                                           int s：起点
                                                           int[] edgeTo:索引代表顶点，值代表从起点s到当前顶点路径上的最后一个顶点

             路径查找过程：


                初始状态
                                                                     (0)------------(2)
                  edge To                                             |\          / /|
                     [ ][ ][ ][ ][ ][ ]                               |  \    /    / |
                      0  1  2  3  4  5                                |   (1)     /  |
                                                                      |         /    |
                                                                      |       (3)    |
                                                                      |   /       \  |
                                                                      | /           \|
                                                                     (5)            (4)


                第一次搜索0顶点的邻接表中的2顶点，则修改edge[2] = 0

                                                                     (0)···········>(2)
                  edge To                                             |\          / /|
                     [ ][ ][0][ ][ ][ ]                               |  \    /    / |
                      0  1  2  3  4  5                                |   (1)     /  |
                                                                      |         /    |
                                                                      |       (3)    |
                                                                      |   /       \  |
                                                                      | /           \|
                                                                     (5)            (4)

                第二次搜索2顶点的邻接表中的1顶点，则修改edge[1] = 2

                                                                     (0)···········>(2)
                  edge To                                             |\         ·· /|
                     [ ][2][0][ ][ ][ ]                               |  \   ..    / |
                      0  1  2  3  4  5                                |   (1)     /  |
                                                                      |         /    |
                                                                      |       (3)    |
                                                                      |   /       \  |
                                                                      | /           \|
                                                                     (5)            (4)

                第三次搜索2顶点的邻接表中的3顶点，则修改edge[3] = 2
                    已1为起点发现0顶点已经被搜索过，则退回到2继续深度搜索
                                                                     (0)···········>(2)
                  edge To                                             |\         ·· /|
                     [ ][2][0][2][ ][ ]                               |  \   ..    / |
                      0  1  2  3  4  5                                |   (1)    ··  |
                                                                      |        ··    |
                                                                      |       (3)    |
                                                                      |   /       \  |
                                                                      | /           \|
                                                                     (5)            (4)

                第二次搜索3顶点的邻接表中的5顶点，则修改edge[5] = 3

                                                                     (0)···········>(2)
                  edge To                                             |\         ·· /|
                     [ ][2][0][2][ ][ ]                               |  \   ..    / |
                      0  1  2  3  4  5                                |   (1)    ··  |
                                                                      |        ··    |
                                                                      |       (3)    |
                                                                      |   ··      \  |
                                                                      |··           \|
                                                                     (5)            (4)


                最终结果如下

                                                                     (0)···········>(2)
                  edge To                                             |\         ·· /|
                     [ ][2][0][2][3][3]                               |  \   ..    / |
                      0  1  2  3  4  5                                |   (1)    ··  |
                                                                      |        ··    |
                                                                      |       (3)    |
                                                                      |   ··     ··  |
                                                                      |··          ··|
                                                                     (5)            (4)
