Date: 2022 November 11th
Author: Dean Zhou
topic: 有向图

一. 有向图
    a) 有向图定义及相关术语
        定义：a页面跳转到b页面，那么a连接b的方向是a -> b ，b 不能 -> a

        出度：由某个顶点指出的边的个数成为该顶点的出度

        入度：指向某个顶点的边的个数称为该顶点的入度

        有项路径：由一系列顶点组成，对于其中每个顶点都存在于一条有项边，从它指向序列中的下一个顶点

        有项环：一条至少含有一条边，且起点和终点相同的有向路径

    b) 有向图API设计

        类名                                          Digraph

        构造方法                                       Digraph(int V):创建一个包含V顶点但是不包含边的有向图

        成员方法                                       int V():获取图中顶点的数量
                                                      int E():获取图中边的数量
                                                      void addEdge(int V,int W):向有向图中添加一条边V -> W
                                                      Queue<integer> adj(int v):获取由顶点V指出的边所连接的所有顶点
                                                      Digraph reverse():该图的反向图

        成员变量                                       final int V:记录顶点数量
                                                      int E：记录边的数量
                                                      Queue<integer>[] adj:邻接表

    c) 有向图实现
二. 拓补排序:对图中所有的点进行搜索，生产一个有序对线性序列
    定义：给定一副有向图，将所有的顶点排序，使得所有的有向边从前面的元素排到后面的元素(从左到右)
         此时可以明确的表示出每个顶点的优先级
                     -------------------\   --------------------\
                    /                   \/ /                     \/
                   (1)        (0) ----->(3)         (2) ------> (4)  ------> (5)
                               \                     /\
                                 --------------------/
                   html       java基础   jsp        serverlet    ssm         springBoot

    a) 检测有向图中的环

        API设计

        类名                                          DirectedCycle

        构造方法                                       DirectedCycle(Digraph G):创建一个检测环对象，检测图中G是否有环

        成员方法                                       void dfs(Digraph G,int s):深度优先搜索找出G图中V顶点的所有想通顶点
                                                      boolean hasCycle():判断图中是否有环

        成员变量                                       boolean[] Marked:索引代表顶点，值表示当前顶点已经被搜索
                                                      boolean hasCycle:记录图中是否有环
                                                      boolean[] onStack:索引代表顶点,使用栈的思想，记录当前顶点有没有已经处于正在搜索的路径上

        检测有向图成环的过程

            原始状态：
              OnStack [f][f][f][f][f]           (3) --> (0)  <--  (1) --> (4)
                                                         \        /\
                       0  1  2  3  4                      \/     /
                                                             (2)

            以顶点3作为入口，进行搜索，则3进栈：      \/
              OnStack [f][f][f][t][f]           (3) --> (0)  <--  (1) --> (4)
                                                         \        /\
                       0  1  2  3  4                      \/     /
                                                             (2)

            找到顶点3的邻接表，继续搜索0，没有在栈中，则0进栈   \/
              OnStack [t][f][f][t][f]           (3) --> (0)  <--  (1) --> (4)
                                                         \        /\
                       0  1  2  3  4                      \/     /
                                                             (2)

            找到顶点0的邻接表，继续搜索2，没有在栈中，则2进栈
              OnStack [t][f][t][t][f]           (3) --> (0)  <--  (1) --> (4)
                                                         \        /\
                       0  1  2  3  4                      \/     /
                                                             (2)
                                                              /\

            找到顶点2的邻接表，继续搜索1，没有在栈中，则1进栈             \/
              OnStack [t][t][t][t][f]           (3) --> (0)  <--  (1) --> (4)
                                                         \        /\
                       0  1  2  3  4                      \/     /
                                                             (2)

            找到顶点1的邻接表，继续搜索0，0在栈中,则图中有环，结束循环
              OnStack [t][t][t][t][f]           (3) --> (0)  <--  (1) --> (4)
                                                         \        /\
                       0  1  2  3  4                      \/     /
                                                             (2)

    b) 基于深度优先搜索的顶点排序


        API设计

        类名                                          DepthFirstOrder

        构造方法                                       DepthFirstOrder(Digraph G):创建顶点排序对象，生成一个线性序列

        成员方法                                       void dfs(Digraph G,int s):基于深度优先，生成一个线性序列
                                                      Stack<Integer> reversePost():获取顶点线性序列

        成员变量                                       boolean[] Marked:索引代表顶点，值表示当前顶点已经被搜索
                                                      Stack<Integer> reversePost():使用栈，存储顶点序列


        顶点排序过程：
            原始图：                                      原始栈
                   > (2) \
                /          >                               ｜    ｜
             (0)            (4) -- >  (5)                  ｜    ｜
                \          >                               ｜    ｜
                  > (3)  /                                 ｜    ｜
                  >                                        ｜    ｜
                /                                          ｜    ｜
             (1)                                            ------

            以0为顶点入口，开始搜索，递归搜索一直找到顶点5，顶点5邻接表中没有数据
            所以顶点5搜索完毕，入栈

                   > (2) \
                /          >                               ｜    ｜
             (0)            (4) -- >  (5)                  ｜    ｜
                \          >                               ｜    ｜
                  > (3)  /                                 ｜    ｜
                  >                                        ｜    ｜
                /                                          ｜ (5)｜
             (1)                                            ------

            返回顶点4，邻接表中没有其他顶点，4搜索结束，顶点4入栈

                   > (2) \
                /          >                               ｜    ｜
             (0)            (4) -- >  (5)                  ｜    ｜
                \          >                               ｜    ｜
                  > (3)  /                                 ｜    ｜
                  >                                        ｜ (4)｜
                /                                          ｜ (5)｜
             (1)                                            ------

            返回顶点2，邻接表中没有其他顶点，2搜索结束，顶点2入栈

                   > (2) \
                /          >                               ｜    ｜
             (0)            (4) -- >  (5)                  ｜    ｜
                \          >                               ｜    ｜
                  > (3)  /                                 ｜ (2)｜
                  >                                        ｜ (4)｜
                /                                          ｜ (5)｜
             (1)                                            ------

            返回顶点1，继续找邻接表中的顶点3搜索，3邻接表中的顶点4已经被搜索，
            所以3搜索结束，入栈
                   > (2) \
                /          >                               ｜    ｜
             (0)            (4) -- >  (5)                  ｜    ｜
                \          >                               ｜ (3)｜
                  > (3)  /                                 ｜ (2)｜
                  >                                        ｜ (4)｜
                /                                          ｜ (5)｜
             (1)                                            ------


             返回顶点0，邻接表中没有其他顶点，0搜索结束，顶点0入栈

                   > (2) \
                /          >                               ｜    ｜
             (0)            (4) -- >  (5)                  ｜ (0)｜
                \          >                               ｜ (3)｜
                  > (3)  /                                 ｜ (2)｜
                  >                                        ｜ (4)｜
                /                                          ｜ (5)｜
             (1)                                            ------


             继续以1作为入口，邻接表中的3已经被搜索，1搜索结束，1入栈，整个图搜索完毕

                   > (2) \
                /          >                               ｜ (1)｜
             (0)            (4) -- >  (5)                  ｜ (0)｜
                \          >                               ｜ (3)｜
                  > (3)  /                                 ｜ (2)｜
                  >                                        ｜ (4)｜
                /                                          ｜ (5)｜
             (1)                                            ------

    c) 拓补排序实现

        API设计

        类名                                          TopoLogical

        构造方法                                       TopoLogical(Digraph G):构造拓补排序对象

        成员方法                                       boolean isCycle():判断图G是否有环
                                                      Stack<Integer> order():获取拓补排序的所有顶点

        成员变量                                       Stack<Integer> order:顶点的拓补排序                                                  Stack<Integer> reversePost():使用栈，存储顶点序列


三. 加权无向图
    a)定义：加权无向图是一种为每条边关联一个权重值或是成本的模型（最小成本问题）

    b) 加权无向图边的表示
        API设计

        类名                                          Edge implement Comparable<Edge>

        构造方法                                       Edge(int v,int w,double weight):通过顶点v和顶点w，以及权重weight值构造一个边对象

        成员方法                                       double weight():获取边的
                                                      int either():获取边上的一个点
                                                      int other(int vertex):获取除了vertex外的另一个顶点
                                                      int compareTo(Edge that):比较当前边和参数that的权重，如果当前权重大，返回1，一样大返回0，
                                                                                当前权重小，返回-1

        成员变量                                       final int v:顶点一
                                                      final int w:顶点二
                                                      double weight:当前边大权重


    c) 加权无向图的实现
        API设计

        类名                                          EdgeWeightedGraph

        构造方法                                       EdgeWeightedGraph(int V):创建含有一个V顶点的空加权无向图

        成员方法                                       int V():获取图中顶点的数量
                                                      int E():获取图中边的数量
                                                      void addEdge(Edge e):向加权无向图中添加一条边e
                                                      Queue<Edge> adj(int v):获取和顶点v关联的所有边
                                                      Queue<Edge> edges():获取加权无向图的所有边

        成员变量                                       final int V:记录顶点数量
                                                      int E:记录边的数量
                                                      Queue<Edge>[]adj:邻接表


四. 最小生成树
    a) 定义：
        图的生成树是它的一棵含有其所有顶点的无环连通子图，一副加权无向图的最生成树它的一棵权值
        (树的所有边的权重之和)最小生成树

      约定：1. 只考虑连通图
           2. 所有边的权重都各不相同，避免最小生成树不唯一的情况

    b) 最小生成树原理
        性质1：用一条边接树中任意两个顶点都会产生一个新的环

        性质2：从树中删除任意一条边，将会得到两颗独立的树

       切分定理：
        切分：将图中所有顶点按照某些规则分为两个非空切没有交集的集合

        横切边：连接两个属于不同集合的顶点的边称之为横切边

        定义：在一副加权图中，给定任意的切分，它的横切边中权重最小的者必然属于图中最小生成树
          注意：一次切分产生多个横切边中，权重最小的边不一定是所有横切遍中唯一属于最小生成树的边
                               (1)
                      (1)      /   (2)
                      | \   /       |
                      |   (1)      (2)
                      (1)    \   /    \
                              (1)       (2)
                    连接1集合和2集合的横切边为权重最小的边

    c) 贪心算法：
        贪心算法是计算最小生成树的基础算法，它的基本原理是切分定理，使用切分定理找到最小生成树的一条边，
        不断重复直到找到最小生成树的所有边

    d) prim算法：
        1.prim算法切分规则：
            把最小生成树中的顶点看做是一个集合，把不在最小生成树中的顶点看做是另一个集合

        2.API设计：


        类名                                          PrimMST

        构造方法                                       PrimMST(EdgeWeightedGraph G):根据一副加权无向图，创建最小生成树对象

        成员方法                                       void visit(EdgeWeightedGraph G,int v):将顶点v添加到最小生成树中，并且更新数据
                                                      Queue<Edge> edges():获取最小生成树的所有的边

        成员变量                                       Edge[] edgeTo:索引代表顶点，值表示当前顶点和最小生成树之间的最短边
                                                      double[] distTo:索引代表顶点，值表示当前顶点和最小生成树之间的最短边的权重
                                                      boolean[] marked:索引代表顶点，如果当顶点已经在树中，则值为true ，否为false
                                                      IndexMinPriorityQueue<Double>pq:存放树中的顶点与非树中顶点之间的有效横切边


        3.Prim算法实现原理：

         step1:
            8
            16
            4 5 0.35   4,5　为顶点 ，0.35为权重
            4 7 0.37                              0   1    2      3     4     5    6        7
            5 7 0.28       IndexMinPriorityQueue [ ] [ ] [0.26] [  ] [0.38] [  ] [0.58]  [0.16]
            0 7 0.16
            1 5 0.32
            0 4 0.38                                  (1)
            2 3 0.17                                / |    \
            1 7 0.19                             /    |      (3)
            0 2 0.26                          (5)     |       | \
            1 2 0.36                           |  \   |       |   \
            1 3 0.29                           |     (7)-----(2)    \
            6 2 0.40                           |        \    /  \     \
            3 6 0.52                           |         【0】        \ \
            6 0 0.58                                 /           \
            6 3 0.93                           (4) --------------------   (6)

                            默认0是最小生成树中的唯一顶点
                            与顶点0相连的顶点 4， 6， 7 ，2 ，在 IndexMinPriorityQueue 中对应处存入对应索引值
                            发现0，7的这条边的权重最小，因此0，7属于最小生成树的边


         step2:
            8
            16
            4 5 0.35   4,5　为顶点 ，0.35为权重
            4 7 0.37                              0    1       2      3     4     5      6      7
            5 7 0.28       IndexMinPriorityQueue [ ] [0.19] [0.26] [  ] [0.37] [0.28] [0.58]  [ ]
            0 7 0.16
            1 5 0.32
            0 4 0.38                                  (1)
            2 3 0.17                                / |    \
            1 7 0.19                             /    |      (3)
            0 2 0.26                          (5)     |       | \
            1 2 0.36                           |  \   |       |   \
            1 3 0.29                           |     【7】-----(2)   \
            6 2 0.40                           |        \    /  \     \
            3 6 0.52                           |         【0】       \  \
            6 0 0.58                                 /           \
            6 3 0.93                           (4) --------------------   (6)

                            现在0，7为最小生成树的一部分，找到所有0，7的临接边 1，5，4，2，6
                            保存相应的权重，4，7的权重小于0，4的权重因此保留4-7的权重
                                          0，2的权重小于2，7的权重因此保留0-2的权重
                             发现1，7的这条边的权重最小，因此1，7属于最小生成树的边

                             不断重复上述操作

五. 加权有向图
    a)
    b)
    c)

六. 最短路径
    a)
    b)
    c)
