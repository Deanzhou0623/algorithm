Date: 2022 October 18th
Author: Dean Zhou
topic: 符号表 / 树tree

    一. 符号表（键值对）-map
        1. 概述
            主要目的是将一个键一个值联系起来，键和值存在一一对应的关系，通过键来查找值
            符号表中键具有唯一性

        2. 符号表的API设计
           a)结点类：
                类名                      Node<key,value>

                构造方法                   Node(key,key,Value value,Node next):创建Node对象

                成员变量                   Key key  存储键
                                          Value value 存储值
                                          Node next：存储下一个结点

           b)符号表：
                类名                      SymbolTable<key,value>

                构造方法                   SymbolTable():创建 SymbolTable对象

                成员方法                   Value get (Key key):根据键值key，找到对应的值
                                          void put(Key key, Value val):向符号表中插入一个键值对
                                          void delete(Key key)删除键为key的键值对
                                          int size():获取符号大小

                成员变量                    private Node head:记录首结点
                                           private int N 记录符号表中键值对的个数

           c)有序符号表：
                与符号表的不同点在于 put方法实现Comparable接口，通过key去比较，从而进行排序

                有序插入流程： 必须考虑key一致的情况

                首结点
               [  ,  ] --> [ 1 , 张三 ] -->[ 2 , 李三 ] -->[ 4 , 王五 ] -->[ 5 , 赵六 ]
                                                 \         /\
                                                 \/        /
                                                  [ 3 , 赵六 ]

               有序表put/无序表put：大致思路一样，考虑有无该key元素，但是无需表元素插在链表头，
                                  有序表插在属于自己顺序的位置


    二. 树
        1. 树的定义
            a）定义：树是非常重要的一种数据结构，树是由n(n>=1)有限结点组成的具有层次关系的集合

            b)特点：
                1. 每一个结点有零个或多个子结点
                2. 没有父结点的结点为根结点
                3. 每一个非根结点只有一个父结点
                4. 每一个结点及其后代结点整体上可以看做一棵树，称为当前结点父结点的一个子树

        2. 树的相关术语
            a) 结点的度
                一个结点含有的子树的个数称为该结点的度
            b) 叶结点
                度为0结点称为叶结点，也可以叫做终端结点
            c) 分支结点
                度不为0的结点称为分支结点，也可以叫做非终端结点
            d) 结点的层次
                从根结点开始，根结点层次为1，根的后继层次为2，依次向后推
            e) 结点的层序编号
                将树中结点，按照从上层到下层，同层从左到右的次序排成一个线性序列，把他们编成连续的自然数
            f) 树的度
                树中所有结点的最大值
            g) 树的高度（深度）
                树中结点的最大层次
            h) 森林
                m（m>=0）个互不想交的树的集合，将一根非空树的根结点删去，树就变成一个森林，给树增加一个统一的根结点，树就变成一棵树

            i) 孩子结点
                一个结点的直接后继结点，称为孩子结点
            g) 双亲结点（父结点）
                一个结点的直接前驱结点，称为该结点的双亲结点
            h) 兄弟结点
                同一双亲的孩子结点，互相称为兄弟结点

        3. 二叉树的定义
            a) 定义：
               1. 二叉树：
                    二叉树就是度不超过2的树(每个结点最多有两个字节点)

                                (A)
                               /   \
                            (B)     (E)
                            / \        \
                          (C)  (d)      (F)

               2. 满二叉树:
                    一个二叉树，如果每一个层的结点都达到最大值,则这个二叉树就是满二叉树
                                (A)
                               /   \
                            (B)     (E)
                            / \      / \
                          (C)  (d)  (F) (G)

               3. 完全二叉树：
                    叶结点只能出现在最下层和次下层的，并且最下层的结点都集中在该层最左边的若干位置的二叉树
                                (A)
                               /   \
                            (B)     (E)    次下层
                            / \
                          (C)  (d)        最下层

            b) 二叉查找树的创建
                1. 二叉树的结点类：
                    类名                          Node<key,Value>

                    构造方法                       Node(Key key,Value value,Node left,Node right)：创建Node对象

                    成员方法                       Node left：记录左子结点
                                                  Node right：记录右子结点
                                                  Key key：存储键
                                                  Value value：存储值

                2. 二叉查找树(左边结点小于右边结点)的API设计
                        类名                          BinaryTree<<Key extends Comparable<Key>,Value value>

                        构造方法                       BinaryTree：创建BinaryTree对象

                        成员方法                       Node root：记录根结点
                                                      Node put(Node x,Key key,Value val)：从指定树X上，添加一个键值对，并返回添加后的新树
                                                      Value get(Key key)：根据Key从树中找出对应值
                                                      Value get(Node x,Key key)：从指定树X上，找出对应的key值
                                                      void delete(Key key):根据key删除树中对应的键值对
                                                      Node delete(Node x,Key key):删除指定树x上的键为key的键值对，并返回删除后的新树
                                                      int size():获取元素个数

                                                      额外方法：
                                                      Key min(): 找出树中最小键
                                                      Node key(Node x,) 指定x树中找出最小键

                                                      Key Max():
                                                      Node max(Node x) 指定x树中找出最大键

                     添加元素具体流程:
                        Node put(Node x,Key key,Value val)：

                        第一种情况：x不存在，即树中树元素

                                           (8.根结点)
                        第二种情况：x存在，树种有根结点

                                           (8.根结点)
                          存第二个元素：  (7.B)

                                         (8.A)
                                       /
                                    (7.B)

                          存第三个元素： (9.C)

                                        (8.A)
                                       /     \
                                    (7.B)   (9.C)

                          存第四个元素　： (3.D)

                                        (8.A)
                                       /     \
                                    (7.B)   (9.C)
                                    /
                                  (3.D)

                          存第五个元素：(9.E)

                                        (8.A)
                                       /     \
                                    (7.B)   (9.E)
                                    /
                                  (3.D)

                     删除元素具体流程：
                       需求：删除元素10
                                           (20)
                                         /      \
                                      (10)        (25)
                                    /     \     /    \
                                 (8)      (16) (23)     (26)
                                /   \    /   \
                               (6)   (9) (14)    (17)
                                       /
                                      (12)

                       step1:找到被删除元素的最小结点(右子树中的最小结点)
                       step2:被删除结点的父结点指向被删除结点右子树中的最小结点

                                            (20)
                                                 \
                             (10)被删除  /        (25)
                                      (12)       /     \
                                    /     \
                                 (8)      (16) (23)    (26)
                                /   \     /    \
                              (6)   (9) (14)  (17)


                   3. 二叉树的基本遍历：按照搜索路径遍历 深度优先遍历

                                          (根结点)
                                          /      \
                                    (左子树)    (右子树)

                                           (E)
                                          /   \
                                       (B)     (G)
                                      /   \    /   \
                                    (A)   (D) (F)   (H)
                                           /
                                          (C)


                    前序遍历：先访问根结点，再访问左子树，最后访问右子树 （根左右） EBADCGFH

                    代码实现：preErgodic

                    中序遍历：先访问左子树，中间访问根结点，最后访问右子树（左根右）ABCDEFGH

                    代码实现：midErgodic

                    后序遍历：先访问左子树，再访问右子树，最后访问根结点 （左右根） ACDBFHGE

                    代码实现：afterErgodic


                4. 二叉树的层序遍历
                    层序遍历：从根结点开始(第一层开始)，依次向下，获取每一层结点的值 (广度遍历思想)
                                                (E)
                                               /   \
                                            (B)     (G)
                                           /   \    /   \
                                         (A)   (D) (F)   (H)
                                                /
                                               (C)

                    层序遍历结果：EBGADFHC

                    详细过程：
                        使用队列存储结点，初始化存储根结点E
                            [            ,E]
                        第一次循环，从队列中弹出E，并将左子结点和右子结点弹入队列中
                            [           G,B]E
                        第二次循环，从队列中弹出B，并将左子结点和右子结点弹入队列中
                             [        D,A,G]B,E
                        第三次循环，从队列中弹出G，并将左子结点和右子结点弹入队列中
                             [      H,F,D,A]G,B,E
                        ........
                        ......
                        ....
                        ..
                        依次弹出F，H，C
                             [            ]C,H,F,D,A,G,B,E
                    代码实现：layerErgodic

                5. 二叉树应用案例

                    二叉树最大深度问题：
                        需求：给定一棵树，请计算树的最大深度(树的根结点到最远叶子结点的最长路径上的结点树)
                                                (E)
                                               /   \
                                            (B)     (G)
                                           /   \    /   \
                                         (A)   (D) (F)   (H)
                                                /
                                               (C)
                        最大深度为：4
                        代码实现：maxDepth

                    二叉树折纸问题：
                        需求：
                        请把一段纸条竖着放在桌子上，然后从纸条的下边向上边对折一次，压出折痕后展开。
                        如果从纸条的下边向上边连续对折2次，压出折痕后展开，则有三条折痕 两条下折痕，一条上折痕

                        给定一个参数N，代表纸条从下边向上边连续对折n次，请从上到下打印所有折痕方向
                        N=1时，打印down ，N=2时，打印down down up


                    代码实现：PagerFolding



