Date: 2022 October 2nd
Author: Dean Zhou
topic: linear table


一. 线性表
        1）定义：数据元素之间具有一种"一对一"的逻辑关系

        2）特点：
            a.第一个数组没有前驱，这个数据元素就被称为头节点
            b.最后一个元素没有后继节点，这个数据元素称为尾节点
            c.除了第一个和最后一个数据元素外，其他数据元素有且仅有一个前驱和一个后继节点

        3）数学语言定义：
            （a1,a2,a3...ai-1,ai,ai+1...an-1,an）
             ai-1是ai的前驱
             ai+1是ai的后继节点

        4）线性表分类
            a.顺序存储结构（顺序表）

            b.链式存储结构（链表）


    1.1 顺序表
        1）定义：
            顺序表是在计算机内存中已数组的形式保存的线性表，线性表的存储是用一组连续不断的存储单元

            数组 [ 11 , 32 , 65 , 14 , 32 , 22 , 13 , 8 , 12]
                   0    1    2    3    4    5    6    7   8

        2）顺序表的API实现：
            a. 构造方法 sequenceList(int capacity) 创建容量为capacity的sequenceList对象
            b. public void clear()空置线性表
            c. public boolean isEmpty()判断线性表是否为空
            d. public int length() 判断线性表中的个数
            e. public T get(int i) 读取并返回线性表中的第i个元素
            f. public void insert(int i,T t) 在线性表i元素之前插入一个值为t的元素
            g. public void insert(T t) 在线性表中插入一个值为t的元素
            h. public T remove(int i) 删除并返回线性表中的第i个元素
            j. public int indexOf(T t) 返回线性表中首次出现的指定元素的未序号，若不存在则返回-1

        3）顺序表的遍历

        4） 顺序表的容量可变
            a)添加元素时
                1. 检查当前数组元素大小时候可以容纳新的元素
                2. 如不能容纳则创建一个容量是原数组两倍容量的新数组存储元素

                原数组 [ 1 , 2 , 3 , 4 ]

                要在索引 4 处添加 "10"
                [ 1 , 2 , 3 , 4 , 10 , 空元素 , 空元素 , 空元素 ]


            b)移除元素时
                1. 检查当前元素是否太大
                2. 数据元素的数量不足数组容量的1/4，则创建一个数组容量为1/2的新数组存储元素

                原数组 [ 1 , 2 , 3 ,  ,  ,  ,  ,   ,   ,   ]

                需要删除3索引处的元素

                [1 , 2 ,   ,  , ]


        5)顺序表时间复杂度分析
            a.get(i), 执行一次操作，则时间复杂度 为 O(1)
            b.insert()操作 ，随着元素N增大，移动次数增加，时间复杂度 O(n)
            c.remove()操作，要把i后面的位置移动，时间复杂度O(n)



        6) java中ArrayList的实现
            java中的ArrayList底层也是一种顺序表，使用数组实现同样增加了增删改查功能
            a. ArrayList底层用数组实现
            b. ArrayList 有扩容操作（grow）
            c. ArrayList 提供iterator 遍历操作





    1.2 链表
        1) 定义：
            链表是一种物理存储单元非连续的，非顺序的存储结构。数据元素的逻辑顺序是通过中的指针链接次序实现的，
            链表是由一系列的结点组成

        2) API定义：
            类名          Node<T>

            构造方法       Node(T t,Node next)

            成员变量       T item 存储数据
                          Node next： 指向下一个结点

        3）单向链表
           a)定义：
            单向链表是链表的一种，它是由多个结点组成，每个结点都由一个数据域和一个指针域组成，数据域用来存储数据，
            指针域用来指向后继结点。链表的头结点不存储数据，指针域指向第一个存储数据的结点

           b)图解：
                   头结点                                                       尾结点
               [null,next] -> [data,next] -> [data,next] -> [data,next] -> [data,null]

           c)API设计：
           类名                   LinkList<T>

           构造方法                LinkList() 创建LinkList对象

           成员方法                void clear() 空置线性表
                                  boolean isEmpty()判断线性表是否为空
                                  int length() 判断线性表中的个数
                                  T get(int i) 读取并返回线性表中的第i个元素
                                  void insert(int i,T t) 在线性表i元素之前插入一个值为t的元素
                                  void insert(T t) 在线性表中插入一个值为t的元素
                                  T remove(int i) 删除并返回线性表中的第i个元素
                                  int indexOf(T t) 返回线性表中首次出现的指定元素的未序号，若不存在则返回-1

           成员内部类               private class Node<T> 终点类

           成员变量                 private Node head 记录首结点
                                   private int N 记录链表的长度

        4) 双向链表
            a)定义：
                双向链表也叫双向表，是链表的一种，它由多个结点组成，每个结点都有两个数据域和指针域组成，数据域用来存储数据
                指针域用来，指针域用来指向后继结点，另一个指针用来指向前驱结点，链表的头结点和数据域不存数据，指向前驱结点
                的指针域为null，指向后继结点的指针域指向第一个真正存储数据的结点

                    头结点
            [null , null , next] <=> [pre , data , next] <=> [pre , data , next] <=> [pre , data , null]


            b)结点API设计
               类名                           Node<T>

               构造方法                        Node(T t,pre,Node next) 创建Node对象

               成员变量                        T item 存储数据
                                              Node next：指向下一个结点
                                              Node pre：指向上一个结点



            c)双向链表API设计
            类名                   TowWaylinkList<T>

            构造方法                TowWayLinkList() 创建TowWayLinkList对象

            成员方法                void clear() 空置线性表
                                   boolean isEmpty()判断线性表是否为空
                                   int length() 判断线性表中的个数
                                   T get(int i) 读取并返回线性表中的第i个元素
                                   void insert(int i,T t) 在线性表i元素之前插入一个值为t的元素
                                   void insert(T t) 在线性表中插入一个值为t的元素
                                   T remove(int i) 删除并返回线性表中的第i个元素
                                   int indexOf(T t) 返回线性表中首次出现的指定元素的未序号，若不存在则返回-1
                                   T getFirst():获取第一个元素
                                   T getLast():获取最后一个元素

            成员内部类               private class Node<T> 终点类

            成员变量                 private Node First 记录首结点
                                    private Node Last 记录尾结点
                                    private int N 记录链表的长度


            d)java中LinkedList的实现
                1）LinkedList是用双项链表实现
                    底层是否用双向链表实现
                    终结点类是否有三个域


        5）链表时间复杂度分析
            a)get方法 随着i次数增大，要扫描的次数越多，线性关系 要找n次 时间复杂度O(n)
            b)remove方法 每次移除都要找到 i位置的前一个元素，然后执行操作一次,随着i次数增大，要扫描的次数越多 时间复杂度O(n)
            c)insert方法 也是需要找到i前面一个元素，然后完成插入操作 ， 时间复杂度O(n)

            查询操作多 -- 顺序表
            增删操作多 -- 链表


        6）链表反转
            单链表反转

            a)需求:
                原链表中： 1 -> 2 -> 3 -> 4
                反转后的链表：4 -> 3 -> 2 -> 1

            b)反转API:
                1)void reverse()：对整个链表进行反转
                2)Node reverse(Node curr): 反转链表中的某个结点curr，并把反转后的结点返回

                使用递归可以完成反转，从原链表第一个数据结点开始，依次递归反转调用每一个结点，直到把最后一个反转完毕
                         head
                原链表： [null,  ] --> [ 1 ,  ] --> [ 2 ,  ] --> [ 3 , ] --> [ 4 , ]

                流程：
                    1）调用reverse(Node curr)方法反转每一个结点，从元素1开始；
                    2）如果发现curr还有下一个结点，则递归调用reverse(curr,next)对下一个结点进行反转
                    3）最终递归的出口是元素4的结点，因为它没有下一个元素，当到了出口，让head指向元素4的结点，共递归调用4次
                    4）递归开始返回

                                                             head
                  第四次递归结果：   null  <--[ 4 ,  ] <-- [null,   ]
                                                                        head
                  第三次递归结果：   null  <--[ 3 ,  ] <-- [ 4 ,  ] <-- [null,   ]
                                                                                     head
                  第二次递归结果：   null  <--[ 2 ,  ] <-- [ 3 ,  ] <-- [ 4 ,  ] <-- [null,   ]
                                                                                                   head
                  第一次递归结果：   null  <--[ 1 ,  ] <-- [ 2 ,  ] <-- [ 3 ,  ] <-- [ 4 ,  ] <-- [null,   ]


        7) 快慢指针
            a)定义：
                快慢指针是支两个指针，这两个指针的移动速度一块一慢，以此来制造自己想要的差值
                一般情况下，快指针的移动步长为慢指针的两倍

            b) 中间值问题

               需求： 找出链表的中间值[dd]

               链表： [ aa ] --> [ bb ] --> [ cc ] --> [ dd ] --> [ ee ] --> [ ff ] --> [ gg ]

               快慢指针解决方案： 慢指针一次走一格/快指针一次走两格

                slow fast
                 ｜  ｜
                 \/ \/
                [ aa ] --> [ bb ] --> [ cc ] --> [ dd ] --> [ ee ] --> [ ff ] --> [ gg ]

                            slow        fast
                             ｜          ｜
                             \/         \/
                [ aa ] --> [ bb ] --> [ cc ] --> [ dd ] --> [ ee ] --> [ ff ] --> [ gg ]

                                       slow                 fast
                                        ｜                   ｜
                                        \/                   \/
                [ aa ] --> [ bb ] --> [ cc ] --> [ dd ] --> [ ee ] --> [ ff ] --> [ gg ]

                                                   slow                            fast
                                                    ｜                               ｜
                                                    \/                              \/
                [ aa ] --> [ bb ] --> [ cc ] --> [ dd ] --> [ ee ] --> [ ff ] --> [ gg ]


                当fast指针走完的时候，slow指针正好到达中点位置


        8) 单项链表有环问题

            a）有环/无环

                无环：
                 [ aa ] --> [ bb ] --> [ cc ] --> [ dd ] --> [ ee ] --> [ ff ]
                                                                            /
                                                                          /
                                                                        /
                                                                      /
                                                                    \/
                                                                  [ gg ]

                有环

                [ aa ] --> [ bb ] --> [ cc ] --> [ dd ] --> [ ee ] --> [ ff ]
                                          /\                              /
                                           \                            /
                                             \                        /
                                               \                    /
                                                 \                /
                                                   \            /
                                                     \        \/
                                                        [ gg ]

                判断是否有环的过程：慢指针一次走一格/快指针一次走两格

                 fast slow
                  ｜  ｜
                  \/ \/
                 [ aa ] --> [ bb ] --> [ cc ] --> [ dd ] --> [ ee ] --> [ ff ]
                                           /\                              /
                                            \                            /
                                              \                        /
                                                \                    /
                                                  \                /
                                                    \            /
                                                      \        \/
                                                         [ gg ]
                             fast       slow
                              ｜          ｜
                              \/         \/
                 [ aa ] --> [ bb ] --> [ cc ] --> [ dd ] --> [ ee ] --> [ ff ]
                                           /\                              /
                                            \                            /
                                              \                        /
                                                \                    /
                                                  \                /
                                                    \            /
                                                      \        \/
                                                         [ gg ]
                                       fast                   slow
                                         ｜                     ｜
                                         \/                    \/
                 [ aa ] --> [ bb ] --> [ cc ] --> [ dd ] --> [ ee ] --> [ ff ]
                                           /\                              /
                                            \                            /
                                              \                        /
                                                \                    /
                                                  \                /
                                                    \            /
                                                      \        \/
                                                         [ gg ]

                                                   fast
                                                    ｜
                                                    \/
                 [ aa ] --> [ bb ] --> [ cc ] --> [ dd ] --> [ ee ] --> [ ff ]
                                           /\                              /
                                            \                            /
                                              \                        /
                                                \                    /
                                                  \        slow    /
                                                    \       |    /
                                                      \    \/  \/
                                                         [ gg ]

                                                  slow         fast
                                                    ｜          ｜
                                                    \/          \/
                 [ aa ] --> [ bb ] --> [ cc ] --> [ dd ] --> [ ee ] --> [ ff ]
                                           /\                              /
                                            \                            /
                                              \                        /
                                                \                    /
                                                  \                /
                                                    \            /
                                                      \        \/
                                                         [ gg ]
                                                                       slow fast
                                                                         ｜  ｜
                                                                         \/ \/
                 [ aa ] --> [ bb ] --> [ cc ] --> [ dd ] --> [ ee ] --> [ ff ]
                                           /\                              /
                                            \                            /
                                              \                        /
                                                \                    /
                                                  \                /
                                                    \            /
                                                      \        \/
                                                         [ gg ]

        9) 有环链表入口问题：查找环入口结点
                慢指针一次走一格/快指针一次走两格 temp一次走一格
                当fast和slow相遇时，则生成另一个指针temp
                   temp                                                 slow fast
                    |                                                    ｜  ｜
                   \/                                                    \/ \/
                 [ aa ] --> [ bb ] --> [ cc ] --> [ dd ] --> [ ee ] --> [ ff ]
                                           /\                              /
                                            \                            /
                                              \                        /
                                                \                    /
                                                  \                /
                                                    \            /
                                                      \        \/
                                                         [ gg ]

                              temp      fast
                               ｜          ｜
                               \/         \/
                 [ aa ] --> [ bb ] --> [ cc ] --> [ dd ] --> [ ee ] --> [ ff ]
                                           /\                              /
                                            \                            /
                                              \                        /
                                                \                    /
                                                  \        slow    /
                                                    \       |    /
                                                      \    \/  \/
                                                         [ gg ]

                                      temp slow               fast
                                        |  ｜                  ｜
                                        \/ \/                  \/
                 [ aa ] --> [ bb ] --> [ cc ] --> [ dd ] --> [ ee ] --> [ ff ]
                                           /\                              /
                                            \                            /
                                              \                        /
                                                \                    /
                                                  \                /
                                                    \            /
                                                      \        \/
                                                         [ gg ]

       10) 循环链表

            a)定义：
                链表整体要形成一个圆环状，实现循环链表，只需要让最后一个结点指向头结点即可

            b)

        单项链表：
             第一个结点                                                        最后一个结点
            [data,next] --> [data,next] --> [data,next] --> [data,next] --> [data,next]

        循环链表：
            第一个结点                                                        最后一个结点
           [data,next] --> [data,next] --> [data,next] --> [data,next] --> [data,next]
                     /\                                                      /
                       \                                                   /
                         \                                               /
                           \-------------------------------------------/

       11) 约瑟夫问题

            需求：
              41个人坐成一圈，第一个人的编号为1，第二个人的编号为2，第三个为3依次向后推，第n个人的编号为n
              1.编号为1的人开始从1报数，依次向后，报数为3的人退出圈
              2.自退出的那个人开始的下一个人重新报1，以此类推
              3.求出最后退出来的那个人的编号

                               顺时间旋转
                             - ---->  (1) 报数1
                           (41)            \
                          /                  \
                        (40)                   (2) 报数2
                        /                        \
                      /                            \
                      (39)                         (3) 报数3 out
                        \                           /
                         \                        /
                         (38)                   (4) 报数1
                           \                    /
                             \                /
                                 ........ (5)

            解题思路：
             1. 构建含有1个结点的单项循环链表，分别储存1-41的值，分别代表41个人
             2. 使用计数器count记录当前报数的值，
             3. 遍历链表，每循环一次count++
             4. 判断count的值，如果是3，则从链表中删除这个结点并打印结点的值，把count置为0
    1.3 栈
         a)栈的概念
            1.定义：
                计算机中的栈，就是供数据休息的地方
                栈是基于一种先进先出的的数据结构(FILO) first in last out
                                压栈            弹栈
             进栈顺序1，2，3，4 --------｜   |---------  弹栈顺序 4，3，2，1
                                      \/  \/
                                  ｜         ｜
                                  ｜    4    ｜   <- 栈顶
                                  ｜    3    ｜
                                  ｜    2    ｜
                                  ｜    1    ｜   <= 栈底
                                   ————————---



            2.栈的实现
                API设计
                构造方法                   Stack():创建stack对象

                成员方法                    boolean isEmpty()判断栈是否为空
                                           int size() 获取栈中的元素个数
                                           T pop() 弹出栈顶元素
                                           void push(T t) 向栈中压入元素t

                成员变量                    private Node head 记录首结点
                                           private int N 当前栈的元素个数

                成员内部类                   private class Node 结点类


         b)栈的实现
              stack class已实现

         c)案例
              1. 括号匹配问题：

              需求：给定一个字符里面可能包含"（）"和其他符号，请检查该字符串中的小括号是否成对出现

              e.g: (上海)(北京) best match
                   上海((北京)) best match
                   上海(北京(广州)(深圳)长沙) best、 match
                   上海(北京)) not match
                   ((上海)北京 not match

              解决思路：
                    key：判断字符是不是左括号，如果是，则放入栈中存储
                         判断字符是不是右括号，如果不是则继续循环
                         如果是右括号，则栈中弹出一个元素t
                         判断元素t是否为null，如果不是则证明有元素左括号，如果不是则证明没有对应元素左括号
                         循环结束后，如果还有左括号则不匹配，否则匹配


              2.逆波兰表达式求值问题

                1.定义：
                    a)
                    中缀表达式： 1+3*2 /2 -（1+3） 都是中缀表达式
                    特点：二元运算符总是置于两个操作数中间

                    b)
                    后缀表达式:运算符总是放在跟他相关的操作数之后


                    中缀表达式                         后缀表达式
                       a+b                               ab+
                      a+(b-c)                           abc-+
                     a+(b-c)*d                          abc-d*+
                     a*(b-c)+d                          abc-*d+

                2.解决思路：

                        ReversePolishNotation


    1.4 队列
            1.定义：
                队列是一种先进先出的数据结构(FIFO)，是一种只能在一端插入，在另一端进行删除操作的特殊线性表
                按照先进先出的原则存储数据，先进入的数据，在读数据的时间先被读出来


                入队 1，2，3，4 --------｜
                                      \/
                                  ｜         ｜
                                  ｜    4    ｜   <- 栈顶
                                  ｜    3    ｜
                                  ｜    2    ｜
                                  ｜    1    ｜   <= 栈底
                                       /\
                                        |--------------- 出队 1，2，3，4



            2. 队列API设计
                类名                   Queue

                构造方法                Queue():创建Queue对象

                成员方法                boolean isEmpty()判断队列是否为空
                                       int size() 获取队列中的元素个数
                                       T dequeue() 从队列中获取一个元素
                                       void enqueue(T t) 往队列中插入一个元素

                成员变量                private Node head 记录首结点
                                       private int N 当前栈的元素个数
                                       private Node last：记录最后一个元素结点

                成员内部类               private class Node 结点类


