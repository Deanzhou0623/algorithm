1. 字符串匹配算法
    1. BF 算法
       Brute Force

       for example:

       a b d e a     a, d 不等 往后移一位 指导 主串和模式串中的第一个字符相对
       d e a

       最大时间复杂度 O(m*n)
       最小时间复杂度 O(n)
    2. BM 算法
       Boyer - Moore

       H E R E   I|S|  A  S I {M【P】L E}  E X A M (P) L E
       E X A M P L|E| s和e不匹配则
                    --->
                     E X A M P L【E】   P和E不匹配，但是 p字符在模式串中出现过则
                         --->
                         E X A {M【P】L E}  移动模式串至相对应的位置
                            --->
                                        E X A M P L (E)  P和E不匹配 ，坏字符匹配规则 -->
                                       --> 移动2位
                                           E X A M P L E
       step1:比较尾部 s和e处 如果s和e不匹配则 s被称为"坏字符" eg：｜S｜

       step2:判断坏字符是否在 模式串中出现过 --> 如果不出现，则直接移到 S "坏字符"的后一位
                                         -->如果出现，则移到该字符和模式串中出现位置  【P】
                                 坏字符移动规则:
                                   坏字符下标 - 模式串中上依次出现位置(如果元素未出现则未-1)
                                    【P】 6  -  4【P】 = 2 则移动两位

       step3:从尾部开始进行比较依次向前推一位，直到比较到坏字符
               坏字符之后至模式串结尾的字符称为"好后缀" eg：　{mple}
                                 好后缀移动规则：
                            好后缀位置(以最后一个字符计算) - 模式串中上依次出现位置(如果元素未出现则未-1)
                            eg: (A B) C D (A B)
                                 0 1       4 5   --> 5-1 = 4 移动4位
                            eg：A B C D (E F)
                                         4 5
                                                ---> 5 - (-1) =6

       step4:比较好后缀 {MPLE} {PLE} {LE} {E} 发现只有E出现在头部则
                        6 - 0 = 6 移动6位
             比较坏字符和好后缀移动规则，哪个更大移动那个

       step5：重复step2的操作 ，从后往前进行一个相关的比较
              如果需要继续查找 则（6-0）把模式串中的第一个移到主串中的最后一个

        m为主串长度 n为模式串长度
        最坏时间复杂度： O(mn)
        最好时间复杂度： O(n/m)


    3. KMP算法： Knuth-Morris-Pratt算法

        主串   |B| B C  {A}B C D A B()A B C D A B【C】D A B D E
        模式串  |A| B C D A B D
                --->
                  |A| B C D A B D                           A与B不匹配，向后移
                  ---->
                      {A}B C D A B (D)                      {A} 与 {A}匹配 ， （D）与 （空格）不匹配 移动4位
                        --->
                               A B（C）D A B D               C与空格）不匹配  2 - 0 =2 移动2位

                        --->
                                      A B C D A B【D】 【C】与【D】 不匹配 根据规则计算 6 - 2 = 4
                                                                                移动4位
        step1: 首字符串比较 ，全部匹配则结束比较，不匹配向后移,一直移到与模式串中第一位匹配字符位置

        step2：逐位进行相关的比较，直到主串中的字符与模式串中的字符不匹配的时候

        step3: 根据部分匹配表计算移动位数: 移动位数 = 已匹配字符数 - 对应部分匹配值（匹配部分的最后一个字符）
                                                   6  - 2 = 4

        搜索词  A   B   C   D   A   B   D

        部分匹  0   0   0   0   1   2   0
        配值
                                               部分匹配值生成规则：
        字符串：bread                       eg: A的前缀和后缀都为空集，则元素共有长度0
        前缀： b，br ，bre，brea                 AB的 前缀A 和 后缀B ，则元素共有长度0
                                               ABC的 前缀AB，A 和 后缀B,BC，则元素共有长度0
        后缀： read,ead,ad,d                   ....
                                           ABCDA的 前缀 A,AB,ABC,ABCD 后缀：BCDA,CDA,DA,A
                                                   共有元素 'A' ,长度为 1
                                   ABCDAB的 前缀 A,AB,ABC,ABCD,ABCDA 后缀：BCDAB,CDAB,DAB,AB,A
                                                   共有元素 'AB' ,长度为 2
                                               ....

        step4：移动4位，从头比较看是否匹配 ，如果不匹配，则根据部分匹配表计算移动位数移动字符

        step5：重复step1的操作

        step6：重复step2 && step3的操作

        step7：重复step1

        时间复杂度 O(M+N)

        BM效率比KMP算法快 3-5倍

