Date: 2022 September 31th
Author: Dean Zhou
topic: 平衡树/B-树/B+树


一. 平衡树:任意子结点的高度都小于等于1
    a)  2-3查找树
        1. 定义：2-3查找树结点可以分为两类
                2-结点：含有一个键和两条链，左链接指向2-3结点的键都小于该结点，右链接指向的2-3结点的键都大于该结点

                3-结点：含有两个键和三条链，左链接指向的2-3树中的键都小于该结点，中间链接指向的2-3树中的键都位于
                       该结点的两个键之间，右链接指向的2-3树中的键都大于该结点
                       A,C 都小于E  H在E,J之间  L大于J

                                           (M)
                                        /       \
                            3-结点 -->(E,J)       (R) <-- 2-结点
                                   /  ｜  \     /    \
                               (A,C) (H) (L)  (P)   (S,X)
                               /   \  <--空链接


        2. 查找：
             二叉树的查找算法能够直接应用到2-3树上面

             图示：查找H

             step1：H小于M，继续在左子树中查找

                                          【M】
                                        /       \
                                     (E,J)       (R)
                                   /  ｜  \     /    \
                               (A,C) (H) (L)  (P)   (S,X)
                               /   \ <-代表空链接，不能走了

             step2：H大于E，小于J，继续在中子树中查找

                                           (M)
                                        /       \
                                    【E,J】       (R)
                                   /  ｜  \     /    \
                               (A,C) (H) (L)  (P)   (S,X)
                               /   \

             step3：查找命中
                                           (M)
                                        /       \
                                     (E,J)       (R)
                                   /  ｜  \     /    \
                               (A,C) 【H】 (L) (P)   (S,X)
                               /   \

        3. 2-3树插入：
            2-3树都插入与二叉查找树插入元素一样

            图示：插入K

            情况1：向2-结点中插入 新键

                                           (M)
                                        /       \
                                     (E,J)       (R)
                                   /  ｜  \     /    \
                               (A,C) (H) (L)  (P)   (S,X)
                               /   \     /  \
                                   未命中查找结束于L的左链接

                                           (M)
                                        /       \
                                    （E,J)        (R)
                                   /  ｜  \      /    \
                               (A,C) (H)【K,L】 (P)   (S,X)
                               /   \
                                将2-结点替换为一个新的含有k的3-结点

            情况2：向一个含有3-结点的树中插入新键

                    插入S：
                                     (A,E)  <---没有空间储存S
                                    /  ｜  \

                                    (A,E,S)  <---创建一个4-结点，S大于A和E，s在最右边
                                   /  ｜ ｜ \

                                       (E)
                                      /    \
                                    (A)    (S) <---分解4-结点：将中间键提升，生成2-结点

            情况3：向父结点为2-结点的3-结点中插入新键

            插入Z
            step1:
                                           (M)
                                        /       \
                                    （E,J)        (R)
                                   /  ｜  \      /    \
                               (A,C) (H) (L)  (P)   (S,X) <--对于z的查找结束于这里，比x大

            step2:
                                            (M)
                                         /       \
                                     （E,J)        (R)
                                    /  ｜  \      /    \
                                (A,C) (H) (L)  (P)   (S,X,Z) <--将3-结点替换为包含Z的4-结点
                                                      / | | \

            step3:
                                            (M)
                                         /       \
                                     （E,J)       (R,X) <--将2-结点替换为含有中间键3-结点
                                    /  ｜  \      /  |  \
                                (A,C) (H) (L)   (P) (S) (Z)<--将4-结点分解为2个2-结点，将中键移到父结点中

            情况4：向一个父结点为3-结点的3-结点中插入新键

            插入D
            step1:
                                           (M)
                                        /       \
                                    （E,J)        (R)
                                   /  ｜  \      /    \
               D的查找结束到这-> (A,C) (H) (L)   (P)   (S,X)

            step2：
                                           (M)
                                        /       \
                                    （E,J)        (R)
                D加入3-结点          /  ｜  \      /    \
                变为临时4-结点->(A,C,D) (H) (L)  (P)   (S,X)
                              / | | \
            step3：
                                           (M)
                                        /       \
                                   (C,E,J)        (R)
                               /  ｜   ｜  \      /    \
                             (A) (D) (H)  (L)   (P)   (S,X)
                             / \ / \ / \  /  \  / \  /  |  \
                             ｜   ｜
                           将结点4-分解为两个2-结点
                           将中间键移到父结点
            step4：
                                          (E,M)  <-- 将E加入2-结点，变为3-结点
              4-结点分解为2个            /    ｜    \
         2-结点，将中键移到父结点 ->   (C)     (J)     (R)
                                /  ｜   /     |    /    \
                              (A) (D) (H)   (L)  (P)     (S,X)
                              / \ / \ / \  /  \  / \    /  |  \

            情况5：分解跟结点
                  当插入结点到根结点的路径上全部是3-结点的时候，最终我们的根结点会临时编程
                  一个4-结点，此时，就需要将根结点拆分为2个2-结点，树的高度加1

                    插入D
                    step1：
                                          （E,J)
                                         /  ｜  \
                   D的查找结束到这->    (A,C) (H) (L)

                    step2：
                                          （E,J)
                                         /  ｜  \
                   D加入3-结点变为-> (A,C,D) (H) (L)
                   临时4-结点         / | \ / \  / \

                    step3：
                                        (C,E,J)   <- 将c加入3-结点，变为临时4-结点
                                     /   /  ｜  \
                                    (A) (D) (H) (L)
                                    / \ / \ / \ / \

                    step4：
                                           (E)
                                          /   \
                                        (C)    (J)     <- 4-结点分解为3个2-结点 ，树高+1
                                      /    \   /   \
                                    (A)   (D) (H)  (L)
                                    / \   / \ / \   / \


        4.2-3树的性质：
            一个完全平衡的2-3树具有以下特质：
            1. 任意空链接到根结点的路径长度都是相等的
            2. 4-结点变换为3-结点时，树的高度不会发生变化，只有当根结点是临时4-结点的时候，分解根结点+1
            3. 2-3树与普通普通二叉树查找树最大的区别在于，普通二叉查找树是自顶向下生长，而2-3树是自底向上

        5. 2-3树的实现：


    b) 红黑树
        1. 定义：
            红黑树主要是对2-3树进行编码，红黑树背后的基本思想是用标准的二叉查找树(完全由2-结点构成的)
            和一些额外的信息(替换3-结点)来表示2-3树。我们将树中的链接分为两个类型
            红链接：将两个2-结点连起来构成一个3-结点
            黑链接：是2-3树中的普通链接

            (E,J) ，(A,C)，(S,X)
            代表红链接
                                           (M)
                                        /       \
                                     [J]          (R)
                                   /     \       /    \
                                [E]      (L)   (P)     [X]
                               /   \    /   \ /   \    /   \
                             [C]   (H)               [S]
                            /   \ /   \             /   \
                          [A]

          红黑树标准定义:
            红黑树是含有红黑链接并满足下列条件的二叉查找树：
            1. 红链接均为左链接
            2. 没有任何一个结点同时和两条红链接相连
            3. 该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同

            红黑树：

                                           (M)
                                        /       \
                                     [J]          (R)
                                   /     \       /    \
                                [E]      (L)   (P)     [X]
                               /   \    /   \ /   \    /   \
                             [C]   (H)               [S]
                            /   \ /   \             /   \
                          [A]

            红链接水平绘制：
                                             (M)
                                          /       \
                                [E] —— [J]          (R)
                                /   \     \       /      \
                       [A] —— [C]   (H)    (L)   (P)  [S]——[X]
                      /   \      \ /   \  /   \ /   \ /  \    \

            2-3树：

                                           (M)
                                        /       \
                                    （E,J)        (R)
                                   /  ｜  \      /    \
                               (A,C) (H) (L)   (P)   (S,X)

        2. 红黑树API设计
                 类名                                   Node<Value,Key>

                 构造方法                                Node(Key key,Value value,Node left,Node right,boolean color):创建Node对象

                 成员变量                                Node left：记录左子结点
                                                        Node right：记录右子结点
                                                        Key key：存储key
                                                        Value value：存储值
                                                        boolean color：由其父结点指向它的链接的颜色
                [ ] --[ ] 表示之间是红链接
                                           [E]  <-- h
                                        /       \
          h.left.color的值是true   -> [C]          [J]  <--  h.right.color的值是false
                                   /     \       /    \
                                (A)      (D)   [G]

        3. 平衡化
            1. 左旋
                当某个结点的左子树为黑色，右子树为红色此时需要左旋

                左旋过程：
                1. 让x的左子结点变为h的右子结点：h.right=x.left;
                2. 让h成为x的左子结点：x.left=h;
                3. 让h的color属性变为x的color的属性值x.color=h.color
                4. 让h的color属性变为red：h.color=true；

                [ ] --[ ] 表示之间是红链接
                                     [E]  <-- 结点h
                                   /     \
                               (小于E)    [s] <--结点x
                                         /  \
                              (介于e和s之间)  (大于S)

                         左旋后：
                                    [S]
                                   /   \
                                 [E]   (大于S)
                                /   \
                            (小于E) (介于e和s之间)
            2. 右旋
                当某个结点的左子结点是红色，且右子姐点的左子结点也是红色，需要左旋
                前提：当前结点为h,它的左子结点为x

                [ ] --[ ] 表示之间是红链接

                                    [S]
                                   /   \
                                 [E]   [大于S]
                                /   \
                            (小于E) (介于e和s之间)

                右旋后：

                                     [E]  <-- 结点h
                                   /     \
                              [小于E]    [s] <--结点x
                                         /  \
                              (介于e和s之间)  (大于S)


        4. 红黑树的插入
            1.向单个2-结点中插入新键
               一棵只含有一个键的红黑树只含有2-结点，插入另一个键，马上将它旋转

              -.新键小于当前结点的键，只需要增加一个红色结点即可，新的红黑树和3-结点完全等价

                      原始红黑树         (b)
                                       /  \

                     向左插入a元素        [b]
                                       /   \
                                     [a]
                                     /  \
              -. 新建大于当前结点的键，那么新增的红色结点将会产生一条红色的链接，通过左旋，形成新的
                 红黑树依然和3-结点等价，含有两个键，一条红色链接

                      原始红黑树         (b)
                                       /  \

                     向左插入a元素        [b]
                                       /   \
                                           [c]
                                           /  \

                       左旋              [c]
                                        /  \
                                      [b]
            2. 向底部的2-结点插入新键
               用和二叉树相同的方式向一棵红黑树中插入一个新键，会在树的底部增加一个结点

                     原始红黑树          (E)
                                      /    \
                                    (A)    [S]
                                   /   \  /   \
                                         [R]
                                        /   \


                     插入C             (E)
                                     /    \
                                   [A]     [S]
                                  /   \    /   \
                                      [C] [R]
                                      / \ / \

                     左旋
                                       (E)
                                     /    \
                                   [C]     [S]
                                  /   \    /   \
                                 [A]     [R]
                                 / \     / \



        5. 颜色反转
            当一个结点的左子结点和右子结点的color都为RED时，也就是出现了临时的4-结点，
            此时需要把左子结点和右子结点的颜色变为black，当前结点颜色变为red

                    临时4-结点        ｜                     ｜
                                    [E]                  (A,E,S)
                                   /   \                 /  | | \
                                 [A]   [S]
                                /   \  /  \


                    颜色反转         |                       |
                                   [E]                     (E)
                                  /   \                   /   \
                                (A)    (S)              (A)    (S)
                               /  \    /  \            /  \    /  \

        6. 向一颗双键树(即一个3-结点)插入新键
              三种子情况
               1. 新键大于原树中的两个键

                      原始红黑树                    [B]
                                                  /  \
                                                [a]
                                               /  \

                      向右插入C元素
                                                   [B]
                                                  /   \
                                                [a]   [C]
                                               /   \  /   \
                      颜色反转
                                                   (B)
                                                  /   \
                                                (a)   (C)
                                               /   \  /   \

               2. 新键小于原树中的两个键


                      原始红黑树                    [C]
                                                  /  \
                                                [B]
                                               /  \

                      向左插入A元素
                                                   [C]
                                                  /   \
                                                [B]
                                               /   \
                                             [A]
                                            /   \

                      右旋
                                                    [B]
                                                   /   \
                                                 [a]   [C]
                                                /  \   /  \

                      颜色反转                       |
                                                   (B)
                                                  /   \
                                                (a)   (C)
                                               /   \  /   \
               3.新键介于原数中两个键之间
                      原始红黑树                    [C]
                                                  /  \
                                                [A]
                                               /  \

                      向左插入A元素
                                                   [C]
                                                  /   \
                                                [A]
                                               /   \
                                                   [B]
                                                  /   \

                      左旋
                                                   [C]
                                                  /   \
                                                [B]
                                               /   \
                                             [A]
                                            /   \

                      右旋
                                                    [B]
                                                   /   \
                                                 [a]   [C]
                                                /  \   /  \

                      颜色反转                       |
                                                   (B)
                                                  /   \
                                                (a)   (C)
                                               /   \  /   \
        7. 根结点颜色总是黑色
               由于根结点不存在父结点，所以每次插入操作之后，都需要把根结点的颜色变为黑色

        8. 向树的底部3-结点插入新键
                      原始红黑树                    (E)
                                                  /  \
                                                [C]   [S]
                                               /   \  /  \
                                             [A]     [R]
                                            /   \   /   \


                      插入H
                                                   (E)
                                                  /   \
                                                [C]    [S]
                                               /   \   /  \
                                             [A]      [R]
                                            /   \    /   \
                                                   [H]
                                                  /   \

                      右旋
                                                   (E)
                                                  /   \
                                                [C]    [R]
                                               /   \   /  \
                                             [A]     [H]  [S]
                                            /   \   /   \ /   \

                      颜色转换
                                                   [E]      点E,R之间存在红链接
                                                  /   \     点C,E之间不存在红链接
                                                [C]    [R]
                                               /   \   /  \
                                             [A]     (H)  (S)
                                            /   \   /   \ /   \

                      左旋
                                                    [R]
                                                   /   \      点C,E之间不存在红链接
                                                 [E]    (S)
                                                /   \   /  \
                                              [C]   (H)
                                             /   \
                                           [A]
                                          /   \

        9. 红黑树的API设计
                类名                                       RedBlackTree<Key extends Comparable<Key>,Value>

                成员方法                                    RedBlackTree():创造redblackTree对象

                成员变量                                    Boolean isRed():判断当前结点的父结点指向链接是否为红色
                                                           Node rotateLeft(Node h):左旋调整
                                                           Node rotateRight(Node h):右旋调整
                                                           void flipColors(Node h):颜色反转，相当于拆分4-结点
                                                           void put(Key key,Value value):在整个树中完成插入操作
                                                           void put(Node h,Key key,Value value):在指定树中完成插入操作，并返回添加元素后的新树
                                                           Value get(Key key):根据key从树中找出对应值
                                                           Value get(Node x,Key key):从指定树中找到对应的key值
                                                           int size():获取树中的元素个数

                成员变量                                    Node root:记录根结点
                                                           int N:记录树中元素个数
                                                           static final boolean Red:红色链接标识
                                                           static final boolean Black:黑色链接标识

        12. 红黑树实现



    c)

二. B-树
    a) 定义：
        B树是一种树状数据结构，它你能够存储数据，对其排序并允许以O(logn)的时间复杂度进行查找，顺序读取，插入删除操作

    b) 特性：B树中包含多个Key，可以是3个，4个，5个甚至更多，选择一个参数M，来构造一个B树
            可以把它称为M阶的B树
            - 每个结点最多有M-1个Key，并且以生序排列
            - 每个结点最多只能有M个子结点
            - 根结点至少有两个子结点

                B树(M=4)
                                                [39   ,    ,    ]
                                                [data ,    ,    ]
                                                   /       \
                                                 /           \
                                         [12   ,22  ,    ]     \
                                         [data ,data,    ]       [53   ,    ,    ]
                                        /        |        \      [data ,    ,    ]
                                      /          |          \                    |   \
                      [ 5   ,  8 ,  9 ]  [ 13  ,  15 ,   ] [25  , 29 ,35  ]      |     \
                      [data ,data,data]  [data ,data ,   ] [data,data,data]      |       \
                                                                      [41   ,50  ,    ]     [97   ,    ,    ]                                                                                             [data ,    ,    ]
                                                                      [data ,data,    ]     [data ,    ,    ]
    c)  B树插入数据
            M=5
            构造5阶B树


            step1:空树中插入39
                                                  [39   ,    ,    ,     ]
                                                  [data ,    ,    ,     ]


            step2:继续插入22，97，41
                                                  [22   , 39 , 41  , 97  ]
                                                  [data ,data,data ,data ]

            step3:继续插入53

                                                  [41   ,    ,    ,     ]
                                                  [data ,    ,    ,     ]
                                                /       \
                                              /           \
                                            /               \
                             [22   , 39 ,    ,    ]       [41   , 97 ,    ,     ]
                             [data ,data,    ,    ]       [data ,data,    ,     ]


            step4:继续插入13，21

                                                  [41   ,    ,    ,     ]
                                                  [data ,    ,    ,     ]
                                                /       \
                                              /           \
                                            /               \
                             [13   , 21 , 22 , 39 ]       [53   , 97 ,    ,     ]
                             [data ,data,data,data]       [data ,data,    ,     ]


            step4:继续插入40

                                                  [22   , 41 ,    ,     ]
                                                  [data ,data,    ,     ]
                                                /       ｜        \
                                              /         ｜          \
                                            /           ｜            \
                        [13   , 21 ,    ,    ][39   , 40 ,    ,     ] [53   , 97 ,    ,     ]
                        [data ,data,    ,    ][data ,data,    ,     ] [data ,data,    ,     ]

            step5:继续插入30，27，33；36,35,34,24,29

                                                  [22   , 33 , 36  ,41   ]
                                                  [data ,data,data ,data ]
                                                /       ｜     \    \       \
                                              /         ｜       \      \         \
                                            /           ｜         \       \            \
                                          /             ｜           \        \               \
                                        /               ｜             \          \                \
                  [13   , 21 ,    ,    ][24  , 27 , 29 , 30 ][34  , 35 ,   ,   ][39  , 40 ,   ,   ][53   , 97 ,    ,     ]
                  [data ,data,    ,    ][data,data,data,data][data,data,   ,   ][data,data,   ,   ][data ,data,    ,     ]


            step5:继续插入30，27，33；36,35,34,24,29


                                                  [33   ,    ,    ,     ]
                                                  [data ,    ,    ,     ]
                                                /       \
                                              /           \
                                            /               \
                             [22   , 27 ,    ,    ]       [36   , 41 ,    ,     ]
                             [data ,data,    ,    ]       [data ,data,    ,     ]
                              /     \     \                  \    \              \
                            /         \      \                 \         \               \
                          /             \       \                \              \                 \
                        /                 \       \                 \                   \                  \
       [13   , 21 ,    ,    ][24  , 26 ,    ,    ][29  , 30 ,   ,   ][34  , 35 ,   ,   ][39  , 40 ,   ,   ][53   , 97 ,    ,     ]
       [data ,data,    ,    ][data,data,    ,    ][data,data,   ,   ][data,data,   ,   ][dara,data,   ,   ][data ,data,    ,     ]

    d) 磁盘
    e) 磁盘IO
三. B+树
    a) 定义：
        B+树是B树的变形树，它与B树的差异在于：
        1. 非叶子结点仅具有索引作用，非叶子结点只存储key，不存储value
        2. 树的所有叶结点构成一个有序链表，可以按照Key排序的次序遍历全部数据
    b) B+树存储过程(插入过程)
            M=5
            构造5阶B树


            step1:空树中插入5
                                                  [5    ,    ,    ,     ]
                                                  [data ,    ,    ,     ]


            step2:继续插入8，10，15
                                                  [5   ,  8 , 10 , 15 ]
                                                  [data,data,data,data]

            step3:继续插入16

                                                  [10  ,    ,    ,     ]
                                                /       \
                                              /           \
                                            /               \
                             [ 5   , 8  ,    ,    ]       [10   , 15 ,16  ,     ]
                             [data ,data,    ,    ]       [data ,data,data,     ]


            step4:继续插入17

                                                  [10   ,    ,    ,     ]
                                                /       \
                                              /           \
                                            /               \
                             [ 5   , 8  ,    ,    ]       [10   , 15 ,16  ,17   ]
                             [data ,data,    ,    ]       [data ,data,data,data ]

            step4:继续插入18

                                                  [10   , 16  ,    ,     ]
                                                /       ｜        \
                                              /         ｜          \
                                            /           ｜            \
                        [ 5   ,  8 ,    ,    ][10   , 15 ,    ,     ] [16   , 17 ,18  ,     ]
                        [data ,data,    ,    ][data ,data,    ,     ] [data ,data,data,     ]

            step5:继续插入6,9,19,20,21,22

                                                  [10   , 16 , 18  ,20   ]
                                                /       ｜     \    \       \
                                              /         ｜       \      \         \
                                            /           ｜         \       \            \
                                          /             ｜           \        \               \
                                        /               ｜             \          \                \
                  [ 5   ,  6 , 8  , 9  ][10   , 15 ,    ,   ][16  , 17 ,   ,   ][18  , 19 ,   ,   ][20   , 21 , 22 ,     ]
                  [data ,data,data,data][data ,data,    ,   ][data,data,   ,   ][data,data,   ,   ][data ,data,data,     ]


            step5:继续插入7


                                                  [16   ,    ,    ,     ]
                                                /       \
                                              /           \
                                            /               \
                             [7   , 10  ,    ,    ]       [18   , 20  ,    ,     ]
                              /     \     \                     \    \              \
                            /         \      \                    \         \               \
                          /             \       \                    \              \                 \
                        /                 \       \                     \                   \                  \
  [ 5   ,  7 ,    ,    ] -> [ 7  ,  8 ,  9 ,    ] ->[10  , 15 ,   ,   ]->[16  , 17 ,   ,   ]->[18  , 19 ,   ,   ]->[53   , 97 ,    ,     ]
  [data ,data,    ,    ]    [data,data,data,    ]   [data,data,   ,   ]  [data,data,   ,   ]  [dara,data,   ,   ]  [data ,data,    ,     ]

    c)B树B+树的比较
      B树：每个结点都包含Key和Value，因此只需要找到key的值就能找到value，但B+树叶子结点只存储数据
           所以每次查找都只能一次一次，一直找到树的最大深度

      B+树：B+树在非叶子结点上不包含真正的数据，只当作索引使用，因此在内存相同的情况下，能存放更多key
           B+树的叶子结点都是相连的，因此对整颗树的遍历只需要一次遍历叶子结点即可，由于顺序是相连的和有序的，所以便于查找和搜索

    d)b+树在数据库中的应用：
        在数据库中建立索引提高查询效率
        建立索引实质是通过B+树的非叶子结点不存储数据只存索引这一特性实现的

        区间查询，由于B+树叶子结点相连和有序的，比如需要查12，18之间的数据那么只需要查12，18就可以

 四. 并查集
    a) 定义&功能
        定义：并查集是一种树形结构
        功能：1. 查询元素p和元素q是否属于同一组
             2. 合并元素q和元素p所在组

             第一组数据  [1,3,5]   |  ---->   3和5属于同组
             第二组数据  [2]       |  查询     1和2不属于同组
             第三组数据  [4,6,7]   | 第二组合并到第一组  ----> [1,2,3,5]
                                                           [4,6,7]

    b) 特点：
        1. 每个元素都是唯一对应的结点
        2. 每一组数据包含多个元素都在同一组树种
        3. 一个组中的数据对应的树和另一个组中的数据对应的树之间没有任何关联
        4. 元素在树中没有子父集关系的硬性要求

             第一组数据  [1,3,5]          (1)
                                        /  \
                                      (3)   (5)


             第二组数据  [2]               (2)



             第三组数据  [4,6,7]                 (6)
                                               /
                                             (4)
                                            /
                                          (7)


    c) API设计
        类名                                          UF

        构造方法                                       UF(int N):初始化并查集，以整数标识(0,N-1)个结点

        成员方法                                       int count():获取当前并查集中的数据有多少个分组
                                                      boolean connnected(int p,int q):判断并查集中元素p和q是否在同一组中
                                                      int find(int p):元素p所在分组的标识符
                                                      void union(int p,int q):把p元素的分组和q元素的分组合并

        成员变量                                       int[] eleAndGroup:记录结点元素和该元素所在的标识
                                                      int count：记录并查集中数据的分租个数

        UF构造方法实现：
            1.初始情况下，每个元素都在一个独立的分组中，所以默认情况下并查集默认分为N个组
            2.初始化EleAndGroup
            3.把eleAndGroup数组的索引看做是每个结点存储的元素，把eleAndGroup数组每个索引处的值看做是该结点所在分组
              那么初始情况下，i索引处存储的值就是i

                    eleGroup [0,1,2,3,4,5,6,7,8] <-- 索引处存储的值标识该元素所在组的标识
                              0 1 2 3 4 5 6 7 8  <-- 索引看做是每个结点存储的元素

        union(int p,int q)合并方法实现：
            1. 如果p和q在同一个分组中，则无需合并
            2. 如果p和q不在同一个分组中，则只需要将p元素所在组的所有元素的组标识符修改为q元素所在组的标识符即可
            3. 分组数量-1

                      eleGroup [0,0,2,0,2,2,6,6,6]
                                0 1 2 3 4 5 6 7 8
                                        |
                                     union(0,2)
                                        |
                                        \/
                      eleGroup [2,2,2,2,2,2,6,6,6]
                                0 1 2 3 4 5 6 7 8


    d)并查集的优化：
        并查集时间复杂度O(n^2),效率太低需要进行优化

        1. 对eleAndGroup进行重新定义：
            仍然让eleAndGroup数组的索引作为某个结点的元素
            eleAndGroup[i]值不再是当前结点所在的分组标识，而是该结点的父结点

                    eleGroup [0,1,2,3,4,5,6,7,8] <-- 索引处存储的值表示该元素的父结点
                              0 1 2 3 4 5 6 7 8  <-- 索引看做是每个结点存储的元素

        2.重写find和union方法

            find方法优化思路
            1. 判断当前元素p的父结点eleAndGroup[p]是不是自己，如果是自己则证明是根结点
            2. 如果当前元素p的父结点不是自己，则让p=eleAndGroup[p]，继续找父结点的父结点，直达根结点为止


                                find(0)

                    eleGroup [(0),1,2,3,4,5,6,7,8] <-- 索引处存储的值表示该元素的父结点
                               0   1 2 3 4 5 6 7 8  <-- 索引看做是每个结点存储的元素

                      1 为0的父结点，由于0！=1，所以当前0结点不是根结点，继续找1的父结点


                    eleGroup [ 0,(1),2,3,4,5,6,7,8]
                               0  1  2 3 4 5 6 7 8
                      3 为1的父结点，由于1！=3，所以当前1结点不是根结点，继续找3的父结点

                    eleGroup [0,1,2,(3),4,5,6,7,8]
                              0 1 2  3  4 5 6 7 8
                      5 为3的父结点，由于3！=5，所以当前3结点不是根结点，继续找5的父结点

                    eleGroup [ 0,1,2,3,4,(5),6,7,8]
                               0 1 2 3 4  5  6 7 8
                      5 为3的父结点，由5 = 5，所以当前5结点是根结点，所以找到find(0)元素
                        所在分组标识为5，查找结束


            union优化思路：
            1. 找到p元素所在数的根结点
            2. 找到q元素所在树的根结点
            3. 如果p和q已经在同一树中，则无需合并
            4. 如果p和q不在同一个分组中，则只需要将p元素所在结点的父结点设置为q元素的根结点即可
            5. 分组数量-1

                                   union(0,6)
                        eleGroup [ 0,3,2,5,4,5,7,8,8]
                                   0 1 2 3 4 5 6 7 8

                        find (5)                 find (8)
                              ｜                       ｜
                             (3)                      (7)
                              ｜                       ｜
                             (1)                      (6)
                              ｜
                             (0)

                        让5的父结点变为8
                        eleGroup [ 0,3,2,5,4,[8],7,8,8]
                                   0 1 2 3 4  5  6 7 8

                                            (8)
                                           /   \
                                         (3)   (7)
                                         /        \
                                       (1)         (6)
                                       /
                                     (0)

            优化后性能分析：
            find 查找效率为：最好情况O(1) 最坏情况O(N)
            union 最好情况为O(1) 最坏情况O(N^2)


    e) 并查集-案例-畅通工程
        某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直通的城镇。省政府畅通工程的目标是使全省任何
        两个城镇实现畅通（不一定要直接相连，只要相互之间道路可达） 最少还需要建设多少条道路
        测试数据中有一个traffic_project.txt文件，它就是城镇道路统计表

                                         20       --- 城市个数
                                         7        --- 已修建好的道路数目
                                         0 1      -
                                         6 9      |
                                         3 8      |
                                         5 11     | -->  已经修好的城市道路每行数据代表2个城市，
                                         2 12     |      表示这两个城市已经相通
                                         6 10     |
                                         4 8      -

        解题思路：使用并查集union方法合并两个城市表示畅通，直到扫描完文档中的所有数据，count-1，即可以得到还需要修建多少条路
                -1是因为合并到最后会剩下一棵树 所有是需要-1
        代码实现：day08 uf traffic_project_test