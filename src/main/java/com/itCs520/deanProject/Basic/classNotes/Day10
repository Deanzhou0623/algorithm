Date: 2022 November 11th
Author: Dean Zhou
topic: 有向图

一. 有向图
    a) 有向图定义及相关术语
        定义：a页面跳转到b页面，那么a连接b的方向是a -> b ，b 不能 -> a

        出度：由某个顶点指出的边的个数成为该顶点的出度

        入度：指向某个顶点的边的个数称为该顶点的入度

        有项路径：由一系列顶点组成，对于其中每个顶点都存在于一条有项边，从它指向序列中的下一个顶点

        有项环：一条至少含有一条边，且起点和终点相同的有向路径

    b) 有向图API设计

        类名                                          Digraph

        构造方法                                       Digraph(int V):创建一个包含V顶点但是不包含边的有向图

        成员方法                                       int V():获取图中顶点的数量
                                                      int E():获取图中边的数量
                                                      void addEdge(int V,int W):向有向图中添加一条边V -> W
                                                      Queue<integer> adj(int v):获取由顶点V指出的边所连接的所有顶点
                                                      Digraph reverse():该图的反向图

        成员变量                                       final int V:记录顶点数量
                                                      int E：记录边的数量
                                                      Queue<integer>[] adj:邻接表

    c) 有向图实现
二. 拓补排序:对图中所有的点进行搜索，生产一个有序对线性序列
    定义：给定一副有向图，将所有的顶点排序，使得所有的有向边从前面的元素排到后面的元素(从左到右)
         此时可以明确的表示出每个顶点的优先级
                     -------------------\   --------------------\
                    /                   \/ /                     \/
                   (1)        (0) ----->(3)         (2) ------> (4)  ------> (5)
                               \                     /\
                                 --------------------/
                   html       java基础   jsp        serverlet    ssm         springBoot

    a) 检测有向图中的环

        API设计

        类名                                          DirectedCycle

        构造方法                                       DirectedCycle(Digraph G):创建一个检测环对象，检测图中G是否有环

        成员方法                                       void dfs(Digraph G,int s):深度优先搜索找出G图中V顶点的所有想通顶点
                                                      boolean hasCycle():判断图中是否有环

        成员变量                                       boolean[] Marked:索引代表顶点，值表示当前顶点已经被搜索
                                                      boolean hasCycle:记录图中是否有环
                                                      boolean[] onStack:索引代表顶点,使用栈的思想，记录当前顶点有没有已经处于正在搜索的路径上

        检测有向图成环的过程

            原始状态：
              OnStack [f][f][f][f][f]           (3) --> (0)  <--  (1) --> (4)
                                                         \        /\
                       0  1  2  3  4                      \/     /
                                                             (2)

            以顶点3作为入口，进行搜索，则3进栈：      \/
              OnStack [f][f][f][t][f]           (3) --> (0)  <--  (1) --> (4)
                                                         \        /\
                       0  1  2  3  4                      \/     /
                                                             (2)

            找到顶点3的邻接表，继续搜索0，没有在栈中，则0进栈   \/
              OnStack [t][f][f][t][f]           (3) --> (0)  <--  (1) --> (4)
                                                         \        /\
                       0  1  2  3  4                      \/     /
                                                             (2)

            找到顶点0的邻接表，继续搜索2，没有在栈中，则2进栈
              OnStack [t][f][t][t][f]           (3) --> (0)  <--  (1) --> (4)
                                                         \        /\
                       0  1  2  3  4                      \/     /
                                                             (2)
                                                              /\

            找到顶点2的邻接表，继续搜索1，没有在栈中，则1进栈             \/
              OnStack [t][t][t][t][f]           (3) --> (0)  <--  (1) --> (4)
                                                         \        /\
                       0  1  2  3  4                      \/     /
                                                             (2)

            找到顶点1的邻接表，继续搜索0，0在栈中,则图中有环，结束循环
              OnStack [t][t][t][t][f]           (3) --> (0)  <--  (1) --> (4)
                                                         \        /\
                       0  1  2  3  4                      \/     /
                                                             (2)

    b) 基于深度优先搜索的顶点排序


        API设计

        类名                                          DepthFirstOrder

        构造方法                                       DepthFirstOrder(Digraph G):创建顶点排序对象，生成一个线性序列

        成员方法                                       void dfs(Digraph G,int s):基于深度优先，生成一个线性序列
                                                      Stack<Integer> reversePost():获取顶点线性序列

        成员变量                                       boolean[] Marked:索引代表顶点，值表示当前顶点已经被搜索
                                                      Stack<Integer> reversePost():使用栈，存储顶点序列


        顶点排序过程：
            原始图：                                      原始栈
                   > (2) \
                /          >                               ｜    ｜
             (0)            (4) -- >  (5)                  ｜    ｜
                \          >                               ｜    ｜
                  > (3)  /                                 ｜    ｜
                  >                                        ｜    ｜
                /                                          ｜    ｜
             (1)                                            ------

            以0为顶点入口，开始搜索，递归搜索一直找到顶点5，顶点5邻接表中没有数据
            所以顶点5搜索完毕，入栈

                   > (2) \
                /          >                               ｜    ｜
             (0)            (4) -- >  (5)                  ｜    ｜
                \          >                               ｜    ｜
                  > (3)  /                                 ｜    ｜
                  >                                        ｜    ｜
                /                                          ｜ (5)｜
             (1)                                            ------

            返回顶点4，邻接表中没有其他顶点，4搜索结束，顶点4入栈

                   > (2) \
                /          >                               ｜    ｜
             (0)            (4) -- >  (5)                  ｜    ｜
                \          >                               ｜    ｜
                  > (3)  /                                 ｜    ｜
                  >                                        ｜ (4)｜
                /                                          ｜ (5)｜
             (1)                                            ------

            返回顶点2，邻接表中没有其他顶点，2搜索结束，顶点2入栈

                   > (2) \
                /          >                               ｜    ｜
             (0)            (4) -- >  (5)                  ｜    ｜
                \          >                               ｜    ｜
                  > (3)  /                                 ｜ (2)｜
                  >                                        ｜ (4)｜
                /                                          ｜ (5)｜
             (1)                                            ------

            返回顶点1，继续找邻接表中的顶点3搜索，3邻接表中的顶点4已经被搜索，
            所以3搜索结束，入栈
                   > (2) \
                /          >                               ｜    ｜
             (0)            (4) -- >  (5)                  ｜    ｜
                \          >                               ｜ (3)｜
                  > (3)  /                                 ｜ (2)｜
                  >                                        ｜ (4)｜
                /                                          ｜ (5)｜
             (1)                                            ------


             返回顶点0，邻接表中没有其他顶点，0搜索结束，顶点0入栈

                   > (2) \
                /          >                               ｜    ｜
             (0)            (4) -- >  (5)                  ｜ (0)｜
                \          >                               ｜ (3)｜
                  > (3)  /                                 ｜ (2)｜
                  >                                        ｜ (4)｜
                /                                          ｜ (5)｜
             (1)                                            ------


             继续以1作为入口，邻接表中的3已经被搜索，1搜索结束，1入栈，整个图搜索完毕

                   > (2) \
                /          >                               ｜ (1)｜
             (0)            (4) -- >  (5)                  ｜ (0)｜
                \          >                               ｜ (3)｜
                  > (3)  /                                 ｜ (2)｜
                  >                                        ｜ (4)｜
                /                                          ｜ (5)｜
             (1)                                            ------

    c) 拓补排序实现

        API设计

        类名                                          TopoLogical

        构造方法                                       TopoLogical(Digraph G):构造拓补排序对象

        成员方法                                       boolean isCycle():判断图G是否有环
                                                      Stack<Integer> order():获取拓补排序的所有顶点

        成员变量                                       Stack<Integer> order:顶点的拓补排序                                                  Stack<Integer> reversePost():使用栈，存储顶点序列


三. 加权无向图
    a)定义：加权无向图是一种为每条边关联一个权重值或是成本的模型（最小成本问题）

    b) 加权无向图边的表示
        API设计

        类名                                          Edge implement Comparable<Edge>

        构造方法                                       Edge(int v,int w,double weight):通过顶点v和顶点w，以及权重weight值构造一个边对象

        成员方法                                       double weight():获取边的
                                                      int either():获取边上的一个点
                                                      int other(int vertex):获取除了vertex外的另一个顶点
                                                      int compareTo(Edge that):比较当前边和参数that的权重，如果当前权重大，返回1，一样大返回0，
                                                                                当前权重小，返回-1

        成员变量                                       final int v:顶点一
                                                      final int w:顶点二
                                                      double weight:当前边大权重


    c) 加权无向图的实现
        API设计

        类名                                          EdgeWeightedGraph

        构造方法                                       EdgeWeightedGraph(int V):创建含有一个V顶点的空加权无向图

        成员方法                                       int V():获取图中顶点的数量
                                                      int E():获取图中边的数量
                                                      void addEdge(Edge e):向加权无向图中添加一条边e
                                                      Queue<Edge> adj(int v):获取和顶点v关联的所有边
                                                      Queue<Edge> edges():获取加权无向图的所有边

        成员变量                                       final int V:记录顶点数量
                                                      int E:记录边的数量
                                                      Queue<Edge>[]adj:邻接表


四. 最小生成树
    a) 定义：
        图的生成树是它的一棵含有其所有顶点的无环连通子图，一副加权无向图的最生成树它的一棵权值
        (树的所有边的权重之和)最小生成树

      约定：1. 只考虑连通图
           2. 所有边的权重都各不相同，避免最小生成树不唯一的情况

    b) 最小生成树原理
        性质1：用一条边接树中任意两个顶点都会产生一个新的环

        性质2：从树中删除任意一条边，将会得到两颗独立的树

       切分定理：
        切分：将图中所有顶点按照某些规则分为两个非空切没有交集的集合

        横切边：连接两个属于不同集合的顶点的边称之为横切边

        定义：在一副加权图中，给定任意的切分，它的横切边中权重最小的者必然属于图中最小生成树
          注意：一次切分产生多个横切边中，权重最小的边不一定是所有横切遍中唯一属于最小生成树的边
                               (1)
                      (1)      /   (2)
                      | \   /       |
                      |   (1)      (2)
                      (1)    \   /    \
                              (1)       (2)
                    连接1集合和2集合的横切边为权重最小的边

    c) 贪心算法：
        贪心算法是计算最小生成树的基础算法，它的基本原理是切分定理，使用切分定理找到最小生成树的一条边，
        不断重复直到找到最小生成树的所有边

    d) prim算法：
        1.prim算法切分规则：
            把最小生成树中的顶点看做是一个集合，把不在最小生成树中的顶点看做是另一个集合

        2.API设计：


        类名                                          PrimMST

        构造方法                                       PrimMST(EdgeWeightedGraph G):根据一副加权无向图，创建最小生成树对象

        成员方法                                       void visit(EdgeWeightedGraph G,int v):将顶点v添加到最小生成树中，并且更新数据
                                                      Queue<Edge> edges():获取最小生成树的所有的边

        成员变量                                       Edge[] edgeTo:索引代表顶点，值表示当前顶点和最小生成树之间的最短边
                                                      double[] distTo:索引代表顶点，值表示当前顶点和最小生成树之间的最短边的权重
                                                      boolean[] marked:索引代表顶点，如果当顶点已经在树中，则值为true ，否为false
                                                      IndexMinPriorityQueue<Double>pq:存放树中的顶点与非树中顶点之间的有效横切边


        3.Prim算法实现原理：

         step1:
            8
            16
            4 5 0.35   4,5　为顶点 ，0.35为权重
            4 7 0.37                              0   1    2      3     4     5    6        7
            5 7 0.28       IndexMinPriorityQueue [ ] [ ] [0.26] [  ] [0.38] [  ] [0.58]  [0.16]
            0 7 0.16
            1 5 0.32
            0 4 0.38                                  (1)
            2 3 0.17                                / |    \
            1 7 0.19                             /    |      (3)
            0 2 0.26                          (5)     |       | \
            1 2 0.36                           |  \   |       |   \
            1 3 0.29                           |     (7)-----(2)    \
            6 2 0.40                           |        \    /  \     \
            3 6 0.52                           |         【0】        \ \
            6 0 0.58                                 /           \
            6 3 0.93                           (4) --------------------   (6)

                            默认0是最小生成树中的唯一顶点
                            与顶点0相连的顶点 4， 6， 7 ，2 ，在 IndexMinPriorityQueue 中对应处存入对应索引值
                            发现0，7的这条边的权重最小，因此0，7属于最小生成树的边


         step2:
            8
            16
            4 5 0.35   4,5　为顶点 ，0.35为权重
            4 7 0.37                              0    1       2      3     4     5      6      7
            5 7 0.28       IndexMinPriorityQueue [ ] [0.19] [0.26] [  ] [0.37] [0.28] [0.58]  [ ]
            0 7 0.16
            1 5 0.32
            0 4 0.38                                  (1)
            2 3 0.17                                / |    \
            1 7 0.19                             /    |      (3)
            0 2 0.26                          (5)     |       | \
            1 2 0.36                           |  \   |       |   \
            1 3 0.29                           |     【7】-----(2)   \
            6 2 0.40                           |        \    /  \     \
            3 6 0.52                           |         【0】       \  \
            6 0 0.58                                 /           \
            6 3 0.93                           (4) --------------------   (6)

                            现在0，7为最小生成树的一部分，找到所有0，7的临接边 1，5，4，2，6
                            保存相应的权重，4，7的权重小于0，4的权重因此保留4-7的权重
                                          0，2的权重小于2，7的权重因此保留0-2的权重
                             发现1，7的这条边的权重最小，因此1，7属于最小生成树的边

                             不断重复上述操作

        4. kruskal 算法
            1. kruskal 算法API设计


        类名                                          KruskalMST

        构造方法                                       KruskalMST(EdgeWeightedGraph G):根据一副加权无向图，创建最小生成树对象

        成员方法                                       Queue<Edge> edges():获取最小生成树的所有的边

        成员变量                                       Queue<Edge> mst:保留最小生成树的所有边
                                                      UF_tree_Weighted uf:索引代表顶点,使用uf_connect(v,w)可以判断顶点v和顶点w是否在同一树中
                                                      使用uf.union(v,w)可以把顶点v所在的树和顶点w所在的树进行合并
                                                      IndexMinPriorityQueue<Edges>pq:存储图中的所有边，使用最小优先队列，对边按照权重进行排序


            2. kruskal算法实现原理

            step1:

            6 4 0.93   4,5　为顶点 ，0.35为权重
            6 0 0.58
            3 6 0.52
            6 2 0.40
            4 7 0.37
            1 2 0.36                                  (1)
            4 5 0.35                                / |    \
            2 7 0.34                             /    |      (3)
            1 5 0.32                          (5)     |       | \
            1 3 0.29                           |  \   |       |   \
            5 7 0.28                           |    【7】-----(2)    \
            0 2 0.26                           |        \    /  \     \
            1 7 0.19                           |         【0】       \   \
            2 3 0.17                                 /           \
          { 0 7 0.16 }                        (4) --------------------   (6)

                pq中按照权重进行排序找出最小权重所在的边和顶点，判断两个顶点是否在同一颗树中不在则相连
                    0 , 7 顶点相关的边权重最小 ，并且0,7 不在同一颗树中 ，0顶点和7顶点相连接


             step2:

            6 4 0.93   4,5　为顶点 ，0.35为权重
            6 0 0.58
            3 6 0.52
            6 2 0.40
            4 7 0.37
            1 2 0.36                                  (1)
            4 5 0.35                                / |    \
            2 7 0.34                             /    |     【3】
            1 5 0.32                          (5)     |       | \
            1 3 0.29                           |  \   |       |   \
            5 7 0.28                           |    【7】-----【2】   \
            0 2 0.26                           |        \    /  \     \
            1 7 0.19                           |         【0】       \   \
           {2 3 0.17}                                /           \
                                              (4) --------------------   (6)

                pq中按照权重进行排序找出最小权重所在的边和顶点，判断两个顶点是否在同一颗树中不在则相连
                    2 , 3 顶点相关的边权重最小 ，并且2,3 不在同一颗树中 ，2顶点和3顶点相连接


                step3:

            6 4 0.93   4,5　为顶点 ，0.35为权重
            6 0 0.58
            3 6 0.52
            6 2 0.40
            4 7 0.37
            1 2 0.36                                  【1】
            4 5 0.35                                / |    \
            2 7 0.34                             /    |     【3】
            1 5 0.32                          (5)     |       | \
            1 3 0.29                           |  \   |       |   \
            5 7 0.28                           |    【7】-----【2】   \
            0 2 0.26                           |        \    /  \     \
           {1 7 0.19}                          |         【0】      \    \
                                                     /           \
                                              (4) --------------------   (6)

                pq中按照权重进行排序找出最小权重所在的边和顶点，判断两个顶点是否在同一颗树中不在则相连
                    1 , 7 顶点相关的边权重最小 ，并且1,7 不在同一颗树中 ，1顶点和7顶点相连接

           依次类推直到：


             6 4 0.93           pq中按照权重进行排序找出最小权重所在的边和顶点，判断两个顶点是否在同一颗树中不在则相连
             6 0 0.58            6 , 2 顶点相关的边权重最小 ，但是6,2两个顶点在同一颗树中，因为不相连，生成最小生成树，结束
             3 6 0.52
           {  6 2 0.40 }
                                                      【1】
                                                     / |    \
                                                  /    |     【3】
                                               [5]     |       | \
                                                |  \   |       |   \
                                                |    【7】-----【2】   \
                                                |        \    /  \     \
                                                |         【0】      \    \
                                                      /           \
                                               [4] --------------------   [6]


五. 加权有向图
    a) 加权有向图边的表示

        API设计

        类名                                          DirectedEdge

        构造方法                                       DirectedEdge(int v,int w,double weight):通过顶点w和v以及weight权重构造一个边对象

        成员方法                                       double weight():获取边的权重值
                                                      int from():获取有向边的起点
                                                      int to():获取有向边的终点

        成员变量                                       final int v:起点
                                                      final int w:终点
                                                      final double weight:当前边的权重

    b) 加权有向图的实现
        API设计

        类名                                          EdgeWeightedDigraph

        构造方法                                       EdgeWeightedDigraph(int V):创建含有一个V顶点的空加权有向图

        成员方法                                       int V():获取图中顶点的数量
                                                      int E():获取图中边的数量
                                                      void addEdge(Edge e):向加权有向图中添加一条边e
                                                      Queue<DirectedEdge> adj(int v):获取由顶点v指出的所有边
                                                      Queue<DirectedEdge> edges():获取加权有向图的所有边

        成员变量                                       final int V:记录顶点数量
                                                      int E:记录边的数量
                                                      Queue<DirectedEdge>[]adj:邻接表


六. 最短路径
    a)  最短路径定义以及性质
        1.定义：在一副加权图中，从顶点s到顶点t的最短路径是从所有顶点s到顶点t的路径中权重最小的那一条路径
             8
             15
             4->5 0.35   4,5　为顶点 ，0.35为权重
             5->4 0.35
             4->7 0.37
             5->7 0.28
             7->5 0.28
             5->1 0.32                                  (1)
             0->4 0.38                                / |    \
             0->2 0.26                             /    |      【3】
             7->3 0.39                          (5)     |       | \
             1->3 0.29                           |  \   |       |   \
             2->7 0.34                           |     【7】----【2】   \
             6->2 0.40                           |        \    /  \     \
             3->6 0.52                           |         【0】       \  \
             6->0 0.58                                 /           \
             6->3 0.93                           (4) -------------------- 【6】

                                        从0到6的最短路径：0 ->2 -> 7 ->3 ->6

        2.性质:
            1. 路径具有方向性
            2. 权重不一定等价于距离，权重可以是距离，时间，花费等内容，权重最小是指成最低
            3. 只考虑连通图，一副图并不是所有的顶点都是可达的，如果s和t不可达，那它们之间不考虑路径，只考虑连通图
            4. 最短路径不一定是唯一的，从一个顶点到另一个顶点的权重最小路径可能有很多条，找出一条即可

        3.最短路径树：
            给定一副加权有向图和一个顶点s，以s为起点的一棵最短路径树是图中一副子图，它包含顶点s以及s可达的所有顶点
            这颗有向图的根结点为s，树的每一条路径都是有向图中的最短路径
    b)  最短路径树API设计

        类名                                          DijkstraSP

        构造方法                                      DijkstraSP(EdgeWeightedDigraph G,int s):根据一副加权有向图
                                                                              和顶点s，创建一个计算顶点s的最短路径树的对象

        成员方法                                       void relax(EdgeWeightedDigraph G,int v):松弛图G中的顶点V
                                                      double distTo(int v):获取从顶点s到顶点v的最短路径的总权重
                                                      boolean hashPathTo(int v):判断从顶点s到顶点v是否可达
                                                      Queue<DirectedEdge> pathTo(int v):查询从起点s到到顶点v的最短路径所有的边

        成员变量                                       DirectedEdge[] edgeTo:索引代表顶点，值表示从顶点s到当前顶点的最短路径上的最后一条边
                                                      double[] distTo:索引代表顶点，值从顶点s到当前顶点的最短路径的总权重
                                                      IndexMinPriorityQueue<Double>pq:存储树中顶点与非树中顶点之间的有效横切边

    c)  松弛技术
        边的松弛：比较到顶点的两个最短路径看哪个更短，对较长那条边进行松弛，保存路径较短那一条边
        顶点松弛：顶点指出对所有边松弛即可
    d)  Dijstra算法实现
